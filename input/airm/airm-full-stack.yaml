---
# Source: airm-chart/templates/airm-app-frontend.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: "airm-ui-sa"
  namespace: "airm"
---
# Source: airm-chart/templates/airm-configure-job.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: "airm-configure-sa"
  namespace: "airm"
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: "airm-dispatcher-sa"
  namespace: "airm"
---
# Source: airm-chart/templates/airm-cluster-roles.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: airm-platform-admin
rules:
  - apiGroups: [""]
    resources:
      [
        "pods",
        "events",
        "services",
        "configmaps",
        "persistentvolumes",
        "persistentvolumeclaims",
        "namespaces",
        "serviceaccounts",
      ]
    verbs: ["get", "list", "watch", "delete"]
  - apiGroups: [""]
    resources: ["pods/log", "pods/exec", "pods/attach", "pods/portforward"]
    verbs: ["*"]
  - apiGroups: ["apps"]
    resources: ["deployments", "replicasets", "statefulsets", "daemonsets"]
    verbs: ["get", "list", "watch", "delete"]
  - apiGroups: ["batch"]
    resources: ["jobs", "cronjobs"]
    verbs: ["get", "list", "watch", "delete"]
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses", "networkpolicies", "httproutes"]
    verbs: ["get", "list", "watch", "delete"]
  - apiGroups: ["kaiwo.silogen.ai"]
    resources: ["kaiwojobs", "kaiwoservices"]
    verbs: ["get", "list", "watch", "delete"]
  - apiGroups: ["config.kaiwo.silogen.ai"]
    resources: ["kaiwoconfigs"]
    verbs: ["*"]
  - apiGroups: ["kaiwo.silogen.ai"]
    resources: ["kaiwojobs", "kaiwoservices", "kaiwoqueueconfigs"]
    verbs: ["*"]
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "watch", "create", "delete"]
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["roles", "clusterroles", "rolebindings", "clusterrolebindings"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["external-secrets.io"]
    resources: ["externalsecrets"]
    verbs: ["get", "list", "watch", "create", "delete"]
  - apiGroups: ["external-secrets.io"]
    resources: ["clustersecretstores"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["kueue.x-k8s.io"]
    resources: ["clusterqueues", "resourceflavors", "localqueues"]
    verbs: ["get", "list", "watch"]
---
# Source: airm-chart/templates/airm-cluster-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: airm-project-member
rules:
  - apiGroups: [""]
    resources:
      [
        "pods",
        "pods/log",
        "pods/exec",
        "pods/attach",
        "pods/portforward",
        "events",
        "services",
        "configmaps",
        "persistentvolumes",
        "persistentvolumeclaims",
      ]
    verbs: ["*"]
  - apiGroups: ["apps"]
    resources: ["deployments", "replicasets", "statefulsets", "daemonsets"]
    verbs: ["*"]
  - apiGroups: ["batch"]
    resources: ["jobs", "cronjobs"]
    verbs: ["*"]
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses", "networkpolicies", "httproutes"]
    verbs: ["*"]
  - apiGroups: ["kaiwo.silogen.ai"]
    resources: ["kaiwojobs", "kaiwoservices"]
    verbs: ["*"]
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["list", "watch", "create"]
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["roles", "clusterroles", "rolebindings", "clusterrolebindings"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["external-secrets.io"]
    resources: ["clustersecretstores", "externalsecrets"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses"]
    verbs: ["get", "list", "watch"]
---
# Source: airm-chart/templates/airm-configure-job.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: "airm-configure-role"
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "create", "delete"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: "airm-dispatcher-cluster-access-role"
rules:
  - apiGroups: [""]
    resources: ["services", "namespaces", "configmaps", "pods"]
    verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["apps"]
    resources: ["deployments", "statefulsets", "daemonsets"]
    verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
  - apiGroups: ["batch"]
    resources: ["jobs", "cronjobs"]
    verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
  - apiGroups: ["kaiwo.silogen.ai"]
    resources: ["kaiwojobs", "kaiwoservices", "kaiwoqueueconfigs"]
    verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
  - apiGroups: ["gateway.networking.k8s.io"]
    resources: ["httproutes"]
    verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses"]
    verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
  - apiGroups: ["external-secrets.io"]
    resources: ["externalsecrets"]
    verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
  - apiGroups: ["apiextensions.k8s.io"]
    resources: ["customresourcedefinitions"]
    verbs: ["get", "list"]
---
# Source: airm-chart/templates/kyverno-cluster-role.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT

# These are additional cluster roles needed by kyverno background controller to be able to
# create rolebindings in namespaces.
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kyverno:airm-policy-roles
  labels:
    rbac.kyverno.io/aggregate-to-background-controller: "true"
rules:
  - apiGroups: ["rbac.authorization.k8s.io"]
    resources: ["clusterroles", "rolebindings"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["rbac.authorization.k8s.io"] # allow kyverno to bind clusterroles via rolebindings
    resources: ["clusterroles"]
    verbs: ["bind"]
---
# Source: airm-chart/templates/kyverno-cluster-role.yaml
# These are additional cluster roles needed by kyverno reports controller to be able to
# manage custom resources for reporting
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kyverno:airm-reports-policy-roles
  labels:
    rbac.kyverno.io/aggregate-to-reports-controller: "true"
rules:
  - apiGroups: ["kaiwo.silogen.ai"]
    resources: ["kaiwojobs", "kaiwoservices"]
    verbs: ["get", "list", "watch"]
---
# Source: airm-chart/templates/airm-cluster-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: airm-platform-admin-role-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: airm-platform-admin
subjects:
  - kind: Group
    # The kubernetes cluster apply an OIDC prefix of 'oidc', so we adjust the group to expect that
    name: "oidcairm-role:Platform Administrator"
    apiGroup: rbac.authorization.k8s.io
---
# Source: airm-chart/templates/airm-configure-job.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: "airm-configure-binding"
subjects:
  - kind: ServiceAccount
    name: "airm-configure-sa"
    namespace: "airm"
roleRef:
  kind: ClusterRole
  name: "airm-configure-role"
  apiGroup: rbac.authorization.k8s.io
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: "airm-dispatcher-cluster-access-binding"
subjects:
  - kind: ServiceAccount
    name: "airm-dispatcher-sa"
    namespace: "airm"
roleRef:
  kind: ClusterRole
  name: "airm-dispatcher-cluster-access-role"
  apiGroup: rbac.authorization.k8s.io
---
# Source: airm-chart/templates/airm-app-backend.yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    app: "airm-api"
  name: "airm-api"
  namespace: "airm"
spec:
  ports:
    - name: web
      port: 80
      targetPort: 8080
    - name: metrics
      port: 9009
      targetPort: 9009
  selector:
    app: "airm-api"
  type: ClusterIP
---
# Source: airm-chart/templates/airm-app-frontend.yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    app: "airm-ui"
  name: "airm-ui"
  namespace: "airm"
spec:
  ports:
    - name: web
      port: 80
      targetPort: 8000
  selector:
    app: "airm-ui"
  type: ClusterIP
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: v1
kind: Service
metadata:
  name: "airm-dispatcher"
  namespace: "airm"
  labels:
    app: "airm-dispatcher"
spec:
  ports:
    - name: web
      port: 80
      targetPort: 8080
  type: ClusterIP
  selector:
    app: "airm-dispatcher"
---
# Source: airm-chart/templates/airm-app-backend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: "airm-api"
  namespace: "airm"
spec:
  replicas: 1
  selector:
    matchLabels:
      app: "airm-api"
  template:
    metadata:
      labels:
        app: "airm-api"
        auth-required: "true"
    spec:
      containers:
        - env:
            - name: OPENID_CLIENT_ID
              value: "354a0fa1-35ac-4a6d-9c4d-d661129c2cd0"
            - name: OPENID_CONFIGURATION_URL
              value: "http://kc.not-a-domain/realms/airm/.well-known/openid-configuration"
            - name: POST_REGISTRATION_REDIRECT_URL
              value: "https://airmui.not-a-domain/"
            - name: DATABASE_HOST
              value: "airm-cnpg-rw.airm.svc.cluster.local"
            - name: DATABASE_PORT
              value: "5432"
            - name: DATABASE_USER
              valueFrom:
                secretKeyRef:
                  key: username
                  name: "airm-cnpg-user"
            - name: DATABASE_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: password
                  name: "airm-cnpg-user"
            - name: RABBITMQ_HOST
              value: "airm-rabbitmq.airm.svc.cluster.local"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_MANAGEMENT_URL
              value: http://airm-rabbitmq.airm.svc.cluster.local:15672/api
            - name: RABBITMQ_ADMIN_USER
              valueFrom:
                secretKeyRef:
                  key: username
                  name: "airm-rabbitmq-admin"
            - name: RABBITMQ_ADMIN_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: password
                  name: "airm-rabbitmq-admin"
            - name: KEYCLOAK_ADMIN_SERVER_URL
              value: "http://keycloak.keycloak.svc.cluster.local:8080"
            - name: KEYCLOAK_REALM
              value: airm
            - name: KEYCLOAK_ADMIN_CLIENT_ID
              valueFrom:
                secretKeyRef:
                  key: client-id
                  name: "airm-keycloak-admin-client"
            - name: KEYCLOAK_ADMIN_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  key: client-secret
                  name: "airm-keycloak-admin-client"
            - name: MINIO_URL
              value: "http://minio.minio-tenant-default.svc.cluster.local:80"
            - name: MINIO_BUCKET
              value: "default-bucket"
            - name: MINIO_ACCESS_KEY
              valueFrom:
                secretKeyRef:
                  key: minio-access-key
                  name: "airm-api-minio-credentials"
            - name: MINIO_SECRET_KEY
              valueFrom:
                secretKeyRef:
                  key: minio-secret-key
                  name: "airm-api-minio-credentials"
            - name: PROMETHEUS_URL
              value: "http://lgtm-stack.otel-lgtm-stack.svc.cluster.local:9090"
          image: "ghcr.io/silogen/airm-api:v2025.09.001"
          imagePullPolicy: IfNotPresent
          livenessProbe:
            failureThreshold: 3
            httpGet:
              path: /v1/health
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
            successThreshold: 1
            timeoutSeconds: 2
          name: airm
          ports:
            - containerPort: 8080
            - containerPort: 9009
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /v1/health
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
            successThreshold: 1
            timeoutSeconds: 2
          resources:
            limits:
              memory: 1Gi
            requests:
              cpu: 500m
              memory: 1Gi
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            runAsUser: 1000
            seccompProfile:
              type: RuntimeDefault
      initContainers:
        - name: wait-for-db
          image: postgres:17-alpine
          command:
            - sh
            - -c
            - |
              until pg_isready -h "airm-cnpg-rw.airm.svc.cluster.local" -p 5432 -U postgres; do
                echo "Waiting for database..."
                sleep 2
              done
              echo "Database is ready!"
        - name: init-migration-scripts
          command:
            - sh
            - -c
            - cp /code/migrations/* /mnt/code/migrations/
          image: "ghcr.io/silogen/airm-api:v2025.09.001"
          imagePullPolicy: "IfNotPresent"
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            runAsNonRoot: true
            runAsUser: 1000
            seccompProfile:
              type: RuntimeDefault
          volumeMounts:
            - mountPath: /mnt/code/migrations
              name: airm-migration-volume
        - name: liquibase-migrate
          command:
            - liquibase
            - --url=jdbc:postgresql://airm-cnpg-rw.airm.svc.cluster.local:5432/airm
            - --username=$(DATABASE_USER)
            - --password=$(DATABASE_PASSWORD)
            - --logLevel=INFO
            - --changeLogFile=changelog/changelog.xml
            - update
          env:
            - name: DATABASE_USER
              valueFrom:
                secretKeyRef:
                  key: username
                  name: "airm-cnpg-user"
            - name: DATABASE_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: password
                  name: "airm-cnpg-user"
          image: "quay.io/lib/liquibase:latest"
          imagePullPolicy: "IfNotPresent"
          volumeMounts:
            - mountPath: /liquibase/changelog
              name: airm-migration-volume
              readOnly: true
        - name: charts-registration
          image: "ghcr.io/silogen/airm-api:v2025.09.001"
          imagePullPolicy: "IfNotPresent"
          command: ["uv", "run", "-m", "app.charts.registration"]
          env:
            - name: DATABASE_HOST
              value: "airm-cnpg-rw.airm.svc.cluster.local"
            - name: DATABASE_PORT
              value: "5432"
            - name: DATABASE_USER
              valueFrom:
                secretKeyRef:
                  name: "airm-cnpg-user"
                  key: username
            - name: DATABASE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: "airm-cnpg-user"
                  key: password
            - name: RABBITMQ_HOST
              value: "airm-rabbitmq.airm.svc.cluster.local"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_MANAGEMENT_URL
              value: http://airm-rabbitmq.airm.svc.cluster.local:15672/api
            - name: RABBITMQ_ADMIN_USER
              valueFrom:
                secretKeyRef:
                  key: username
                  name: "airm-rabbitmq-admin"
            - name: RABBITMQ_ADMIN_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: password
                  name: "airm-rabbitmq-admin"
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            runAsUser: 1000
            seccompProfile:
              type: RuntimeDefault
            capabilities:
              drop:
                - ALL
        - name: check-rabbitmq-is-ready
          command:
            [
              "/bin/bash",
              "-c",
              'apt-get update -y 1> /dev/null 2>&1 && apt-get install ncat -y 1> /dev/null 2>&1 && while ! nc -z "$ENDPOINT_URL_TO_CHECK" "$ENDPOINT_PORT_TO_CHECK"; do echo "Waiting for Airm rabbitmq at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}..."; sleep 3; done; echo "Airm rabbitmq is accepting connections at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}."; sleep 3; exit 0',
            ]
          image: ubuntu:22.04
          imagePullPolicy: IfNotPresent
          env:
            - name: ENDPOINT_URL_TO_CHECK
              value: "airm-rabbitmq.airm.svc.cluster.local"
            - name: ENDPOINT_PORT_TO_CHECK
              value: "15672"
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: false
            runAsUser: 0
            capabilities:
              drop:
                - ALL
              add:
                - SETUID
                - SETGID
                - CHOWN
                - DAC_OVERRIDE
                - FOWNER
                - FSETID
            seccompProfile:
              type: RuntimeDefault

      volumes:
        - emptyDir: {}
          name: airm-migration-volume
---
# Source: airm-chart/templates/airm-app-frontend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: "airm-ui"
  namespace: "airm"
spec:
  replicas: 1
  selector:
    matchLabels:
      app: "airm-ui"
  template:
    metadata:
      labels:
        app: "airm-ui"
    spec:
      serviceAccountName: "airm-ui-sa"
      containers:
        - name: airm-ui
          env:
            - name: NEXTAUTH_URL
              value: "https://airmui.not-a-domain"
            - name: KEYCLOAK_ISSUER
              value: "https://kc.not-a-domain/realms/airm"
            - name: KEYCLOAK_ID
              value: "354a0fa1-35ac-4a6d-9c4d-d661129c2cd0"
            - name: KEYCLOAK_ISSUER_INTERNAL_URL
              value: "http://keycloak.keycloak:8080/realms/airm/"
            - name: AIRM_API_SERVICE_URL
              value: "http://airm-api.airm"
            - name: NEXTAUTH_SECRET
              valueFrom:
                secretKeyRef:
                  name: "airm-secrets-airm"
                  key: NEXTAUTH_SECRET
            - name: KEYCLOAK_SECRET
              valueFrom:
                secretKeyRef:
                  name: "airm-keycloak-ui-creds"
                  key: KEYCLOAK_SECRET
          image: "ghcr.io/silogen/airm-ui:v2025.09.001"
          imagePullPolicy: "IfNotPresent"
          livenessProbe:
            failureThreshold: 3
            httpGet:
              path: /api/health
              port: 8000
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 2
          ports:
            - containerPort: 8000
          resources:
            limits:
              memory: 4Gi
            requests:
              cpu: 500m
              memory: 4Gi
          readinessProbe:
            httpGet:
              path: /api/health
              port: 8000
            initialDelaySeconds: 5
            periodSeconds: 10
      restartPolicy: Always
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: "airm-dispatcher"
  namespace: "airm"
spec:
  replicas: 1
  selector:
    matchLabels:
      app: "airm-dispatcher"
  template:
    metadata:
      labels:
        app: "airm-dispatcher"
    spec:
      serviceAccountName: "airm-dispatcher-sa"
      initContainers:
        - name: check-airm-api-is-ready
          command:
            [
              "/bin/bash",
              "-c",
              'apt-get update -y 1> /dev/null 2>&1 && apt-get install ncat -y 1> /dev/null 2>&1 && while ! nc -z "$ENDPOINT_URL_TO_CHECK" "$ENDPOINT_PORT_TO_CHECK"; do echo "Waiting for Airm UI at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}..."; sleep 3; done; echo "Airm UI is accepting connections at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}."; sleep 12; exit 0',
            ]
          image: ubuntu:22.04
          imagePullPolicy: IfNotPresent
          env:
            - name: ENDPOINT_URL_TO_CHECK
              value: "airm-api.airm.svc.cluster.local"
            - name: ENDPOINT_PORT_TO_CHECK
              value: "80"
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: false
            runAsUser: 0
            capabilities:
              drop:
                - ALL
              add:
                - SETUID
                - SETGID
                - CHOWN
                - DAC_OVERRIDE
                - FOWNER
                - FSETID
            seccompProfile:
              type: RuntimeDefault
      containers:
        - name: airm-dispatcher
          image: "ghcr.io/silogen/airm-dispatcher:v2025.09.001"
          imagePullPolicy: "IfNotPresent"
          ports:
            - containerPort: 8080
          env:
            - name: KUBE_CLUSTER_NAME
              value: demo-cluster
            - name: ORG_NAME
              value: demo
            - name: RABBITMQ_HOST
              value: "airm-rabbitmq.airm.svc.cluster.local"
            - name: RABBITMQ_PORT
              value: "5672"
            - name: RABBITMQ_AIRM_COMMON_VHOST
              value: "vh_airm_common"
            - name: RABBITMQ_AIRM_COMMON_QUEUE
              value: "airm_common"
            - name: RABBITMQ_USER
              valueFrom:
                secretKeyRef:
                  name: "airm-rabbitmq-common-vhost-user"
                  key: username
            - name: RABBITMQ_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: "airm-rabbitmq-common-vhost-user"
                  key: password
          livenessProbe:
            httpGet:
              path: /v1/health
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 2
            failureThreshold: 3
            successThreshold: 1
          readinessProbe:
            httpGet:
              path: /v1/health
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 2
            failureThreshold: 3
            successThreshold: 1
          resources:
            requests:
              memory: "1Gi"
              cpu: "500m"
            limits:
              memory: "1Gi"
          securityContext:
            runAsUser: 0
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: "airm-cluster-nodes-dispatcher"
  namespace: "airm"
spec:
  concurrencyPolicy: Replace
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - command:
                - curl
                - -X
                - POST
                - http://airm-dispatcher:80/v1/clusters/nodes
              image: "ghcr.io/silogen/airm-dispatcher:v2025.09.001"
              imagePullPolicy: "IfNotPresent"
              name: airm-cluster-nodes-cron
              resources:
                limits:
                  memory: 100Mi
                requests:
                  cpu: 50m
                  memory: 100Mi
          restartPolicy: OnFailure
  schedule: 0 * * * *
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: "airm-heartbeat-dispatcher"
  namespace: "airm"
spec:
  concurrencyPolicy: Replace
  schedule: "*/1 * * * *"
  suspend: false
  jobTemplate:
    spec:
      template:
        metadata:
          annotations:
            sidecar.istio.io/inject: "false"
        spec:
          restartPolicy: OnFailure

          initContainers:
            - name: check-dispatcher-is-ready
              command:
                [
                  "/bin/bash",
                  "-c",
                  'apt-get update -y 1> /dev/null 2>&1 && apt-get install ncat -y 1> /dev/null 2>&1 && while ! nc -z "$ENDPOINT_URL_TO_CHECK" "$ENDPOINT_PORT_TO_CHECK"; do echo "Waiting for Airm dispatcher at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}..."; sleep 3; done; echo "Airm dispatcher is accepting connections at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}."; sleep 12; exit 0',
                ]
              image: ubuntu:22.04
              imagePullPolicy: IfNotPresent
              env:
                - name: ENDPOINT_URL_TO_CHECK
                  value: "airm-dispatcher.airm.svc.cluster.local"
                - name: ENDPOINT_PORT_TO_CHECK
                  value: "80"
              securityContext:
                allowPrivilegeEscalation: false
                runAsNonRoot: false
                runAsUser: 0
                capabilities:
                  drop:
                    - ALL
                  add:
                    - SETUID
                    - SETGID
                    - CHOWN
                    - DAC_OVERRIDE
                    - FOWNER
                    - FSETID
                seccompProfile:
                  type: RuntimeDefault
          containers:
            - name: airm-heartbeat-cron
              image: "ghcr.io/silogen/airm-dispatcher:v2025.09.001"
              imagePullPolicy: "IfNotPresent"
              command:
                [
                  "curl",
                  "-X",
                  "POST",
                  "http://airm-dispatcher:80/v1/heartbeats",
                ]
              resources:
                requests:
                  memory: "100Mi"
                  cpu: "50m"
                limits:
                  memory: "100Mi"
---
# Source: airm-chart/templates/airm-app-backend.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/airm-app-frontend.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/airm-cert-issuer.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/airm-cluster.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/airm-configure-job.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/airm-es.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/airm-httproute.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/airm-rabbitmq-cluster.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/secret-generator-configmap.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/secret-generator-job.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/secret-generator-rbac.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT
---
# Source: airm-chart/templates/airm-cert-issuer.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: "airm-tls-secret"
  namespace: "airm"
spec:
  dnsNames:
    - "airm-rabbitmq.airm.svc.cluster.local"
    - "*.airm-rabbitmq-nodes.airm.svc.cluster.local"
  issuerRef:
    kind: Issuer
    name: "airm-selfsigned-issuer"
  secretName: "airm-tls-secret"
---
# Source: airm-chart/templates/airm-cluster.yaml
apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: "airm-cnpg"
  namespace: "airm"
spec:
  affinity:
    enablePodAntiAffinity: true
    topologyKey: topology.kubernetes.io/zone
  bootstrap:
    initdb:
      database: airm
      owner: airm_user
      postInitSQL:
        - GRANT CREATE ON SCHEMA public TO airm_user
      secret:
        name: "airm-cnpg-user"
  imageName: ghcr.io/cloudnative-pg/postgresql:17
  instances: 1
  nodeMaintenanceWindow:
    inProgress: false
    reusePVC: true
  postgresql:
    parameters:
      auto_explain.log_min_duration: "10s"
      pg_stat_statements.max: "10000"
      pg_stat_statements.track: "all"
      shared_buffers: "256MB"
      wal_compression: "pglz" # default is "off"
    pg_hba:
      - host all all 10.244.0.0/16 md5
  primaryUpdateStrategy: unsupervised
  resources:
    limits:
      cpu: "2"
      memory: 1Gi
    requests:
      cpu: "1"
      memory: 512Mi
  startDelay: 300
  stopDelay: 300
  storage:
    size: 50Gi
    storageClass: default
  superuserSecret:
    name: "airm-cnpg-superuser" # airm-cnpg-superuser
  walStorage:
    size: 50Gi
    storageClass: default
---
# Source: airm-chart/templates/airm-cluster-policies.yaml
# Copyright © Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT

apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: airm-project-namespace-rolebinding
spec:
  background: false
  rules:
    - name: generate-project-namespace-rolebinding
      match:
        any:
          - resources:
              kinds:
                - Namespace
              operations:
                - CREATE
      preconditions:
        any:
          - key: '{{request.object.metadata.labels."airm.silogen.ai/project-id" || '''' }}'
            operator: NotEquals
            value: ""
      generate:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: RoleBinding
        name: "{{request.object.metadata.name}}-member-role-binding"
        namespace: "{{request.object.metadata.name}}"
        synchronize: true
        data:
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: airm-project-member
          subjects:
            - kind: Group
              # The kubernetes cluster apply an OIDC prefix of 'oidc', so we adjust the groups to expect that
              name: "oidc{{request.object.metadata.name}}"
              apiGroup: rbac.authorization.k8s.io
---
# Source: airm-chart/templates/airm-cluster-policies.yaml
# Kyverno policy that enforces that workloads submitted to a namespace managed by AIRMan have the
# correct kueue lables and field set, so that they are bound by the quota of the namespace
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: airm-quota-enforcement-for-workloads
spec:
  background: false
  rules:
    - name: set-queue-name-from-namespace-default
      match:
        resources:
          kinds:
            - Deployment
            - StatefulSet
            - Pod
          namespaceSelector:
            matchExpressions:
              - key: airm.silogen.ai/project-id
                operator: Exists
      preconditions:
        all:
          - key: '{{request.object.metadata.labels."kueue.x-k8s.io/queue-name" || '''' }}'
            operator: NotEquals
            value: "{{request.namespace }}"
      mutate:
        patchStrategicMerge:
          metadata:
            labels:
              kueue.x-k8s.io/queue-name: "{{request.namespace }}"

    - name: set-queue-name-from-namespace-jobs
      match:
        resources:
          kinds:
            - Job # https://kueue.sigs.k8s.io/docs/tasks/run/jobs/
          namespaceSelector:
            matchExpressions:
              - key: airm.silogen.ai/project-id
                operator: Exists
      preconditions:
        all:
          - key: '{{request.object.metadata.labels."kueue.x-k8s.io/queue-name" || '''' }}'
            operator: NotEquals
            value: "{{request.namespace }}"
      mutate:
        patchStrategicMerge:
          metadata:
            labels:
              kueue.x-k8s.io/queue-name: "{{request.namespace }}"
          spec:
            suspend: true

    - name: set-queue-name-from-namespace-cronjobs
      match:
        resources:
          kinds:
            - CronJob # https://kueue.sigs.k8s.io/docs/tasks/run/run_cronjobs/
          namespaceSelector:
            matchExpressions:
              - key: airm.silogen.ai/project-id
                operator: Exists
      preconditions:
        all:
          - key: '{{request.object.spec.jobTemplate.metadata.labels."kueue.x-k8s.io/queue-name" || '''' }}'
            operator: NotEquals
            value: "{{request.namespace }}"
      mutate:
        patchStrategicMerge:
          spec:
            jobTemplate:
              metadata:
                labels:
                  kueue.x-k8s.io/queue-name: "{{request.namespace }}"
              spec:
                suspend: true

    - name: set-queue-name-from-namespace-kaiwo
      match:
        resources:
          kinds:
            - KaiwoJob
            - KaiwoService
          namespaceSelector:
            matchExpressions:
              - key: airm.silogen.ai/project-id
                operator: Exists
      preconditions:
        all:
          - key: "{{request.object.spec.clusterQueue || '' }}"
            operator: NotEquals
            value: "{{request.namespace }}"
      mutate:
        patchStrategicMerge:
          spec:
            clusterQueue: "{{request.namespace }}"
---
# Source: airm-chart/templates/airm-cluster-policies.yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: airm-workload-tracking-policy
spec:
  background: false
  rules:
    # For all supported types, if airm.silogen.ai/workload-id and airm.silogen.ai/component-id are not set, we assume
    # it has been submitted from outside of AIRMan. In that case, we set airm.silogen.ai/auto-discovered: true, so it can
    # be tracked upstream. We also set airm.silogen.ai/discovered-component-type so that we can identify the type of component
    # that was originally tracked, and ignore children created by it. See remove-auto-discovered-annotations-inherited-from-parent
    # We also try to capture the user who submitted the workload, and consume it in the application

    # Please note that ReplicaSet is not supported because by default it is filtered away by Kyverno by default: https://github.com/kyverno/kyverno/blob/main/charts/kyverno/values.yaml#L270
    - name: add-discovery-annotations-for-supported-types
      match:
        resources:
          kinds:
            - Job
            - Deployment
            - StatefulSet
            - DaemonSet
            - CronJob
            - KaiwoJob
            - KaiwoService
            - Pod
          namespaceSelector:
            matchExpressions:
              - key: airm.silogen.ai/project-id
                operator: Exists
      preconditions:
        all:
          - key: '{{request.object.metadata.labels."airm.silogen.ai/workload-id" || '''' }}'
            operator: Equals
            value: ""
          - key: '{{request.object.metadata.labels."airm.silogen.ai/component-id" || '''' }}'
            operator: Equals
            value: ""
          - key: '{{request.object.metadata.annotations."airm.silogen.ai/auto-discovered" || '''' }}'
            operator: Equals
            value: ""
      mutate:
        patchStrategicMerge:
          metadata:
            annotations:
              airm.silogen.ai/submitter: "{{request.userInfo.username }}"
              airm.silogen.ai/auto-discovered: "true"
              airm.silogen.ai/discovered-component-type: "{{request.object.kind }}"
    # For all supported types, if airm.silogen.ai/auto-discovered is set and the airm.silogen.ai/discovered-component-type
    # doesnt match the kind of the current component, we assume this type has been created by a parent which is also
    # supported by AIRMan and we dont need to track this type upstream, so we unset the airm.silogen.ai/auto-discovered annotation.
    # This is mostly to account for KaiwoJob and KaiwoService which propagate annotations to pods.
    - name: remove-auto-discovered-annotations-inherited-from-parent
      match:
        resources:
          kinds:
            - Job
            - Deployment
            - StatefulSet
            - DaemonSet
            - CronJob
            - KaiwoJob
            - KaiwoService
            - Pod
          namespaceSelector:
            matchExpressions:
              - key: airm.silogen.ai/project-id
                operator: Exists
      preconditions:
        all:
          - key: '{{request.object.metadata.annotations."airm.silogen.ai/auto-discovered" || '''' }}'
            operator: Equals
            value: "true"
          - key: '{{request.object.metadata.annotations."airm.silogen.ai/discovered-component-type" || '''' }}'
            operator: NotEquals
            value: "{{request.object.kind }}"
      mutate:
        patchStrategicMerge:
          metadata:
            annotations:
              airm.silogen.ai/auto-discovered: "false"
    # For all supported types, if airm.silogen.ai/project-id does not match that of the namespace label, overwrite it
    # with the expected value, to avoid metrics getting mixed up between projects.
    - name: set-project-id-from-namespace-label
      match:
        resources:
          kinds:
            - Job
            - Deployment
            - StatefulSet
            - DaemonSet
            - CronJob
            - KaiwoJob
            - KaiwoService
            - Pod
          namespaceSelector:
            matchExpressions:
              - key: airm.silogen.ai/project-id
                operator: Exists
      context:
        - name: ns_labels
          apiCall:
            urlPath: "/api/v1/namespaces/{{request.namespace }}"
            jmesPath: "metadata.labels"
      preconditions:
        all:
          - key: '{{request.object.metadata.labels."airm.silogen.ai/project-id" || '''' }}'
            operator: NotEquals
            value: '{{ns_labels."airm.silogen.ai/project-id" }}'
      mutate:
        patchStrategicMerge:
          metadata:
            labels:
              airm.silogen.ai/project-id: '{{ns_labels."airm.silogen.ai/project-id" }}'
    # Add the airm.silogen.ai/workload-id and airm.silogen.ai/component-id labels to types that expect them at
    # metadata.labels. The expectation is that these are propagated to the subsequent pods that are created.

    # If the resource is spawned off by a CRD, it will not know about the labels on the previous version of the object,
    # so we also check request.oldObject for the labels to try and preserve them if they were already set.
    - name: add-workload-and-component-id-default
      match:
        resources:
          kinds:
            - Pod
            - KaiwoJob
            - KaiwoService
          namespaceSelector:
            matchExpressions:
              - key: airm.silogen.ai/project-id
                operator: Exists
      mutate:
        patchStrategicMerge:
          metadata:
            labels:
              airm.silogen.ai/workload-id: '{{request.object.metadata.labels."airm.silogen.ai/workload-id" || request.oldObject.metadata.labels."airm.silogen.ai/workload-id" || request.uid }}'
              airm.silogen.ai/component-id: '{{request.object.metadata.labels."airm.silogen.ai/component-id" || request.oldObject.metadata.labels."airm.silogen.ai/component-id" || request.uid }}'
    # Add the airm.silogen.ai/workload-id and airm.silogen.ai/component-id labels to objects with templates and
    # also add it to spec.template.metadata.labels to ensure that the pods created by them contain the labels as well
    - name: add-workload-and-component-id-to-objects-with-template
      match:
        resources:
          kinds:
            - Job
            - Deployment
            - StatefulSet
            - DaemonSet
          namespaceSelector:
            matchExpressions:
              - key: airm.silogen.ai/project-id
                operator: Exists
      mutate:
        patchStrategicMerge:
          metadata:
            labels:
              airm.silogen.ai/workload-id: '{{request.object.metadata.labels."airm.silogen.ai/workload-id" || request.oldObject.metadata.labels."airm.silogen.ai/workload-id" || request.uid }}'
              airm.silogen.ai/component-id: '{{request.object.metadata.labels."airm.silogen.ai/component-id" || request.oldObject.metadata.labels."airm.silogen.ai/component-id" || request.uid }}'
          spec:
            template:
              metadata:
                labels:
                  airm.silogen.ai/workload-id: '{{request.object.metadata.labels."airm.silogen.ai/workload-id" || request.oldObject.metadata.labels."airm.silogen.ai/workload-id" || request.uid }}'
                  airm.silogen.ai/component-id: '{{request.object.metadata.labels."airm.silogen.ai/component-id" || request.oldObject.metadata.labels."airm.silogen.ai/component-id" || request.uid }}'

    # Add the airm.silogen.ai/workload-id and airm.silogen.ai/component-id labels to cronjob and
    # also add it to spec.jobTemplate.metadata.labels to ensure that the pods created by the cronjob
    # contain it as well
    - name: add-workload-and-component-id-cronjobs
      match:
        resources:
          kinds:
            - CronJob
          namespaceSelector:
            matchExpressions:
              - key: airm.silogen.ai/project-id
                operator: Exists
      mutate:
        patchStrategicMerge:
          metadata:
            labels:
              airm.silogen.ai/workload-id: '{{request.object.metadata.labels."airm.silogen.ai/workload-id" || request.oldObject.metadata.labels."airm.silogen.ai/workload-id" || request.uid }}'
              airm.silogen.ai/component-id: '{{request.object.metadata.labels."airm.silogen.ai/component-id" || request.oldObject.metadata.labels."airm.silogen.ai/component-id" || request.uid }}'
          spec:
            jobTemplate:
              metadata:
                labels:
                  airm.silogen.ai/workload-id: '{{request.object.metadata.labels."airm.silogen.ai/workload-id" || request.oldObject.metadata.labels."airm.silogen.ai/workload-id" || request.uid }}'
                  airm.silogen.ai/component-id: '{{request.object.metadata.labels."airm.silogen.ai/component-id" || request.oldObject.metadata.labels."airm.silogen.ai/component-id" || request.uid }}'
              spec:
                template:
                  metadata:
                    labels:
                      airm.silogen.ai/workload-id: '{{request.object.metadata.labels."airm.silogen.ai/workload-id" || request.oldObject.metadata.labels."airm.silogen.ai/workload-id" || request.uid }}'
                      airm.silogen.ai/component-id: '{{request.object.metadata.labels."airm.silogen.ai/component-id" || request.oldObject.metadata.labels."airm.silogen.ai/component-id" || request.uid }}'
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: "airm-cnpg-superuser"
  namespace: "airm"
spec:
  data:
    - remoteRef:
        key: airm-cnpg-superuser-username
      secretKey: username
    - remoteRef:
        key: airm-cnpg-superuser-password
      secretKey: password
  secretStoreRef:
    kind: ClusterSecretStore
    name: airm-secret-store
  target:
    name: "airm-cnpg-superuser"
    template:
      type: Opaque
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: "airm-cnpg-user"
  namespace: "airm"
spec:
  data:
    - remoteRef:
        key: airm-cnpg-user-username
      secretKey: username
    - remoteRef:
        key: airm-cnpg-user-password
      secretKey: password
  secretStoreRef:
    kind: ClusterSecretStore
    name: airm-secret-store
  target:
    name: "airm-cnpg-user"
    template:
      type: Opaque
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: "airm-keycloak-admin-client"
  namespace: "airm"
spec:
  data:
    - remoteRef:
        key: airm-keycloak-admin-client-id
      secretKey: client-id
    - remoteRef:
        key: airm-keycloak-admin-client-secret
      secretKey: client-secret
  secretStoreRef:
    kind: ClusterSecretStore
    name: keycloak-secret-store
  target:
    name: "airm-keycloak-admin-client"
    template:
      type: Opaque
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: "airm-rabbitmq-admin"
  namespace: "airm"
spec:
  data:
    - remoteRef:
        key: airm-rabbitmq-user-username
      secretKey: username
    - remoteRef:
        key: airm-rabbitmq-user-password
      secretKey: password
  secretStoreRef:
    kind: ClusterSecretStore
    name: airm-secret-store
  target:
    name: "airm-rabbitmq-admin"
    template:
      data:
        default_user.conf: |
          default_user = {{ .username }}
          default_pass = {{ .password }}
        password: '{{ .password }}'
        username: '{{ .username }}'
      type: Opaque
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: "airm-api-minio-credentials"
  namespace: "airm"
spec:
  data:
    - remoteRef:
        key: default-user
        property: API_ACCESS_KEY
      secretKey: minio-access-key
    - remoteRef:
        key: default-user
        property: API_SECRET_KEY
      secretKey: minio-secret-key
  secretStoreRef:
    kind: ClusterSecretStore
    name: k8s-secret-store
  target:
    name: "airm-api-minio-credentials"
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: "airm-secrets-airm"
  namespace: "airm"
spec:
  data:
    - remoteRef:
        key: airm-ui-auth-nextauth-secret
      secretKey: NEXTAUTH_SECRET
  refreshInterval: 15s
  secretStoreRef:
    kind: ClusterSecretStore
    name: airm-secret-store
  target:
    name: "airm-secrets-airm"
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: "airm-keycloak-ui-client"
  namespace: "airm"
spec:
  data:
    - remoteRef:
        key: airm-ui-keycloak-secret
      secretKey: KEYCLOAK_SECRET
  secretStoreRef:
    kind: ClusterSecretStore
    name: keycloak-secret-store
  target:
    name: "airm-keycloak-ui-creds"
    template:
      type: Opaque
---
# Source: airm-chart/templates/airm-httproute.yaml
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: 'airmapi-route'
  namespace: 'airm'
spec:
  parentRefs:
    - group: gateway.networking.k8s.io
      kind: Gateway
      name: https
      namespace: kgateway-system
  rules:
    - backendRefs:
        - group: ""
          kind: Service
          name: 'airm-api'
          port: 80
          weight: 1
      matches:
        - headers:
            - name: Host
              type: RegularExpression
              value: airmapi\..*
          path:
            type: PathPrefix
            value: /
      timeouts:
        backendRequest: 20s
        request: 90s
---
# Source: airm-chart/templates/airm-httproute.yaml
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: 'airmui-route'
  namespace: 'airm'
spec:
  parentRefs:
    - group: gateway.networking.k8s.io
      kind: Gateway
      name: https
      namespace: kgateway-system
  rules:
    - backendRefs:
        - group: ""
          kind: Service
          name: 'airm-ui'
          port: 80
          weight: 1
      matches:
        - headers:
            - name: Host
              type: RegularExpression
              value: airmui\..*
          path:
            type: PathPrefix
            value: /
      timeouts:
        backendRequest: 20s
        request: 90s
---
# Source: airm-chart/templates/airm-cert-issuer.yaml
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: "airm-selfsigned-issuer"
  namespace: "airm"
spec:
  selfSigned: {}
---
# Source: airm-chart/templates/airm-rabbitmq-cluster.yaml
apiVersion: rabbitmq.com/v1beta1
kind: RabbitmqCluster
metadata:
  name: 'airm-rabbitmq'
  namespace: 'airm'
spec:
  persistence:
    storage: 20Gi
    storageClassName: default
  replicas: 1
  resources:
    limits:
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi
  secretBackend:
    externalSecret:
      name: 'airm-rabbitmq-admin'
  tls:
    secretName: 'airm-tls-secret'
---
# Source: airm-chart/templates/secret-generator-rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: "airm-secret-generator-sa"
  namespace: "airm"
  annotations:
    helm.sh/hook: pre-install
    helm.sh/hook-weight: "-1"
---
# Source: airm-chart/templates/secret-generator-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: "airm-secret-generator-script"
  namespace: "airm"
  annotations:
    helm.sh/hook: pre-install
    helm.sh/hook-weight: "-1"
data:
  generate-secrets.sh: |
    #!/bin/bash

    # Generate alphanumeric secret function
    generate_secret() {
        openssl rand -hex 16 | tr 'a-f' 'A-F' | head -c 32
    }

    # Generate all secrets first
    AIRM_SUPERUSER_USERNAME=$(generate_secret)
    AIRM_SUPERUSER_PASSWORD=$(generate_secret)
    AIRM_USER_PASSWORD=$(generate_secret)
    AIRM_RABBITMQ_USERNAME=$(generate_secret)
    AIRM_RABBITMQ_PASSWORD=$(generate_secret)
    AIRM_UI_AUTH_SECRET=$(generate_secret)

    # Create the ClusterSecretStore YAML with pre-generated secrets
    cat > /tmp/final-secret-store.yaml << EOF
    apiVersion: external-secrets.io/v1beta1
    kind: ClusterSecretStore
    metadata:
      name: airm-secret-store
    spec:
      provider:
        fake:
          data:
          - key: airm-cnpg-superuser-username
            value: ${AIRM_SUPERUSER_USERNAME}
          - key: airm-cnpg-superuser-password
            value: ${AIRM_SUPERUSER_PASSWORD}
          - key: airm-cnpg-user-username
            value: airm_user
          - key: airm-cnpg-user-password
            value: ${AIRM_USER_PASSWORD}
          - key: airm-rabbitmq-user-username
            value: ${AIRM_RABBITMQ_USERNAME}
          - key: airm-rabbitmq-user-password
            value: ${AIRM_RABBITMQ_PASSWORD}
          - key: airm-ui-auth-nextauth-secret
            value: ${AIRM_UI_AUTH_SECRET}
    EOF

    # Do not apply if the secret store already exists
    kubectl get clustersecretstores.external-secrets.io airm-secret-store > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "ClusterSecretStore 'airm-secret-store' already exists, skipping creation."
        exit 0
    fi

    kubectl apply -f /tmp/final-secret-store.yaml
    echo "ClusterSecretStore created successfully!"
    echo "Generated secrets with alphanumeric values only"
    exit 0
---
# Source: airm-chart/templates/secret-generator-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: "airm-secret-generator-role"
  annotations:
    helm.sh/hook: pre-install
    helm.sh/hook-weight: "-1"
rules:
  - apiGroups: ["external-secrets.io"]
    resources: ["clustersecretstores"]
    verbs: ["create", "update", "patch", "get", "list"]
---
# Source: airm-chart/templates/secret-generator-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: "airm-secret-generator-binding"
  annotations:
    helm.sh/hook: pre-install
    helm.sh/hook-weight: "-1"
subjects:
  - kind: ServiceAccount
    name: "airm-secret-generator-sa"
    namespace: "airm"
roleRef:
  kind: ClusterRole
  name: "airm-secret-generator-role"
  apiGroup: rbac.authorization.k8s.io
---
# Source: airm-chart/templates/airm-configure-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: "airm-configure"
  namespace: "airm"
  annotations:
    "helm.sh/hook": post-install
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": never
spec:
  backoffLimit: 3
  template:
    metadata:
      labels:
        app: "airm-configure"
    spec:
      restartPolicy: Never
      serviceAccountName: "airm-configure-sa"
      initContainers:
        - name: wait-for-dependencies
          image: ubuntu:22.04
          imagePullPolicy: IfNotPresent
          command: ["/bin/bash", "-c"]
          args:
            - |
              apt-get update -y 1> /dev/null 2>&1
              apt-get install curl -y 1> /dev/null 2>&1
              echo "Checking dependencies..."

              # Wait for Keycloak
              echo "Checking keycloak..."
              while true; do
                if curl -s --max-time 5 http://keycloak.keycloak.svc.cluster.local:8080/realms/airm/.well-known/openid-configuration > /dev/null 2>&1; then
                  echo "Keycloak is ready!"
                  break
                else
                  echo "Waiting for Keycloak..."
                  sleep 10
                fi
              done

              # Wait for AIRM API
              echo "Checking airm-api..."
              while true; do
                if curl -s --max-time 5 http://airm-api.airm.svc.cluster.local/v1/health > /dev/null 2>&1; then
                  echo "AIRM API is ready!"
                  break
                else
                  echo "Waiting for AIRM API..."
                  sleep 10
                fi
              done

              # Wait for RabbitMQ (needed for secret creation)
              echo "Checking rabbitmq..."
              while true; do
                if curl -s --max-time 5 http://airm-rabbitmq.airm.svc.cluster.local:15672/api/overview > /dev/null 2>&1; then
                  echo "RabbitMQ is ready!"
                  break
                else
                  echo "Waiting for RabbitMQ..."
                  sleep 10
                fi
              done

              echo "All dependencies are ready!"
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: false
            runAsUser: 0
            capabilities:
              drop:
                - ALL
              add:
                - SETUID
                - SETGID
                - CHOWN
                - DAC_OVERRIDE
                - FOWNER
                - FSETID
            seccompProfile:
              type: RuntimeDefault
      containers:
        - name: configure
          image: "ghcr.io/silogen/airm-configure:v2025.09.001"
          imagePullPolicy: IfNotPresent
          env:
            - name: DEBIAN_FRONTEND
              value: "noninteractive"
            - name: ORG_NAME
              value: "demo"
            - name: NEW_DOMAIN_NAME
              value: "not-a-domain"
            - name: KEYCLOAK_CLIENT_ID
              value: "354a0fa1-35ac-4a6d-9c4d-d661129c2cd0"
            - name: KEYCLOAK_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  key: KEYCLOAK_SECRET
                  name: "airm-keycloak-ui-creds"
            - name: USER_EMAIL
              value: "devuser@not-a-domain"
            - name: KEYCLOAK_URL
              value: "http://keycloak.keycloak.svc.cluster.local:8080"
            - name: AIRM_API_URL
              value: "http://airm-api.airm.svc.cluster.local"
            - name: CLUSTER_BASE_URL
              value: "https://workspaces.not-a-domain/"
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: false
            runAsUser: 0
            capabilities:
              drop:
                - ALL
              add:
                - SETUID
                - SETGID
                - CHOWN
                - DAC_OVERRIDE
                - FOWNER
                - FSETID
            seccompProfile:
              type: RuntimeDefault
---
# Source: airm-chart/templates/secret-generator-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: "airm-secret-generator"
  namespace: "airm"
  annotations:
    helm.sh/hook: pre-install
    helm.sh/hook-weight: "1"
spec:
  template:
    spec:
      serviceAccountName: "airm-secret-generator-sa"
      containers:
        - name: secret-generator
          image: "ghcr.io/silogen/cluster-tool:latest"
          imagePullPolicy: "IfNotPresent"
          command: ["/bin/bash", "-c", "/scripts/generate-secrets.sh"]
          volumeMounts:
            - name: script-volume
              mountPath: /scripts
      volumes:
        - name: script-volume
          configMap:
            name: "airm-secret-generator-script"
            defaultMode: 0755
      restartPolicy: OnFailure
  backoffLimit: 3
