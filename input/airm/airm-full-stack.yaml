---
# Source: airm-chart/templates/airm-app-frontend.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: 'airmchartdemo-airm-ui-sa'
  namespace: 'silodemo-airm'
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: 'airmchartdemo-airm-dispatcher-sa'
  namespace: 'silodemo-airm'
---
# Source: airm-chart/templates/secret-generator-rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: 'airmchartdemo-secret-generator-sa'
  namespace: 'silodemo-airm'
---
# Source: airm-chart/templates/airm-app-frontend.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: 'airmchartdemo-airm-configure'
  namespace: 'silodemo-airm'
data:
  init-db.sh: |

    #!/bin/bash

    apt-get update 1> /dev/null 2>&1
    apt-get install curl jq -y 1> /dev/null 2>&1
    echo "Ubuntu packages ready now"
    echo ""

    cd /opt
    curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    cp ./kubectl /usr/local/bin/kubectl
    chmod +x /usr/local/bin/kubectl
    rm /opt/kubectl
    echo "kubectl tool ready"
    echo ""

    # Wait until critical services are ready
    ###########################################################################

    # Checking that all services are ready: keycloak, airm-api, airm-ui:
    #####################################################################################
    # 1. keycloak
    echo "Checking keycloak..."
    echo ""
    while true; do
        NAMESPACE="keycloak"
        LABEL="app=keycloak"
        CONTAINER="keycloak"

        # Find the first pod name matching label and is Running
        PODS=$(kubectl get pods -n "$NAMESPACE" -l "$LABEL" --field-selector=status.phase=Running -o jsonpath="{.items[*].metadata.name}")
        FIRST_POD=$(echo "$PODS" | awk '{print $1}')
        if [[ -z "$FIRST_POD" ]]; then
            echo "No running pod with label $LABEL in namespace $NAMESPACE found yet."
            echo "Waiting 10 seconds..."
            sleep 10
            continue
        fi
        POD=$FIRST_POD

        echo "Found running pod: $POD"
        # Check if the specific container is present and ready
        IS_READY=$(kubectl get pod "$POD" -n "$NAMESPACE" -o jsonpath="{.status.containerStatuses[?(@.name=='$CONTAINER')].ready}")
        if [[ "$IS_READY" == "true" ]]; then
            echo "Container '$CONTAINER' in pod '$POD' is ready."
            break
        else
            echo "Container '$CONTAINER' in pod '$POD' is NOT ready."
        fi
    done

    #####################################################################################
    # 2. airm-api

    echo "Checking airm-api..."
    echo ""
    while true; do
        NAMESPACE="silodemo-airm"
        LABEL="app=airmchartdemo-airm-api"
        CONTAINER="airm"

        # Find the first pod name matching label and is Running
        PODS=$(kubectl get pods -n "$NAMESPACE" -l "$LABEL" --field-selector=status.phase=Running -o jsonpath="{.items[*].metadata.name}")
        FIRST_POD=$(echo "$PODS" | awk '{print $1}')
        if [[ -z "$FIRST_POD" ]]; then
            echo "No running pod with label $LABEL in namespace $NAMESPACE found yet."
            echo "Waiting 10 seconds..."
            sleep 10
            continue
        fi
        POD=$FIRST_POD

        echo "Found running pod: $POD"
        # Check if the specific container is present and ready
        IS_READY=$(kubectl get pod "$POD" -n "$NAMESPACE" -o jsonpath="{.status.containerStatuses[?(@.name=='$CONTAINER')].ready}")
        if [[ "$IS_READY" == "true" ]]; then
            echo "Container '$CONTAINER' in pod '$POD' is ready."
            break
        else
            echo "Container '$CONTAINER' in pod '$POD' is NOT ready."
        fi
    done

    ###########################################################################

    function check_success() {
        if [ $1 -ne 0 ]; then
            echo "ERROR: $2"
            # exit 0
        fi
    }

    function refresh_token() {
        echo "debug: ${KEYCLOAK_CLIENT_ID} ${KEYCLOAK_CLIENT_SECRET}"
        TOKEN=$(curl -v -s -d "client_id=${KEYCLOAK_CLIENT_ID}" -d "username=${USER_EMAIL}" -d 'password=password' -d 'grant_type=password' -d "client_secret=${KEYCLOAK_CLIENT_SECRET}" "${KEYCLOAK_URL}/realms/airm/protocol/openid-connect/token" | jq -r '.access_token')
        if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
            echo "ERROR: Failed to obtain access token from Keycloak."
            # kill $PF_API_PID $PF_KC_PID $PF_UI_PID
            exit 0
        fi
    }

    function create_org() {
        # Try to get ORG_ID by name
        ORG_ID=$(curl -v -s -X GET "${AIRM_API_URL}/v1/organizations" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H 'Content-Type: application/json' | jq -r --arg name "$ORG_NAME" '.organizations[] | select(.name==$name) | .id')

        # If not found, create the org and fetch the ID again
        if [ -z "$ORG_ID" ] || [ "$ORG_ID" == "null" ]; then
            ORG_RESP=$(curl -v -s -o /dev/null -X POST -w "%{http_code}" "${AIRM_API_URL}/v1/organizations" -H "Authorization: Bearer ${TOKEN}" -H 'Content-Type: application/json' -d "{ \"name\": \"$ORG_NAME\", \"domains\": $ORG_DOMAINS }")

            echo $ORG_RESP
            check_success $([[ "$ORG_RESP" == "200" || "$ORG_RESP" == "201" ]] && echo 0 || echo 1) "Failed to create organization"

            ORG_ID=$(curl -v -s -X GET "${AIRM_API_URL}/v1/organizations" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H 'Content-Type: application/json' | jq -r --arg name "$ORG_NAME" '.organizations[] | select(.name==$name) | .id')
        fi

        if [ -z "$ORG_ID" ] || [ "$ORG_ID" == "null" ]; then
            echo "ERROR: Failed to create or retrieve organization ID."
            # kill $PF_API_PID $PF_KC_PID $PF_UI_PID
            echo "Org demo already exists??"
            #exit 0
        else
            echo "ORG_ID=${ORG_ID}"
        fi
    }

    function add_user_to_org() {
        # Check if user exists in org
        USER_EXISTS=$(curl -v -s -X GET "${AIRM_API_URL}/v1/users" -H 'accept: application/json' -H "Authorization: Bearer ${TOKEN}" -H 'Content-Type: application/json' | jq -r --arg email "$USER_EMAIL" '.users[] | select(.email==$email) | .email')
        # Add user to org if they don't exist
        if [ -z "$USER_EXISTS" ] || [ "$USER_EXISTS" == "null" ]; then
            echo $USER_EXISTS
            echo "User '$USER_EMAIL' not found in organization. Adding..."
            ADD_USER_RESP=$(curl -v -w "%{http_code}" -X 'POST' "${AIRM_API_URL}/v1/organizations/${ORG_ID}/users" -H 'accept: application/json' -H "Authorization: Bearer ${TOKEN}" -H 'Content-Type: application/json' -d '{ "email": "'"$USER_EMAIL"'", "roles": ["Platform Administrator"]}')
            echo $ADD_USER_RESP
            check_success $([[ "$ADD_USER_RESP" == "200" || "$ADD_USER_RESP" == "201" || "$ADD_USER_RESP" == "null201" ]] && echo 0 || echo 1) "Failed to add user to organization"
        else
            echo "User '$USER_EMAIL' already exists in organization."
        fi
    }

    function create_cluster() {
        # Check if cluster exists
        CLUSTER_EXISTS=$(curl -v -s -X GET "${AIRM_API_URL}/v1/clusters" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H 'Content-Type: application/json' | jq -r '.clusters[] | select(.name=="'$CLUSTER_NAME'") | .id')

        if [ -z "$CLUSTER_EXISTS" ] || [ "$CLUSTER_EXISTS" == "null" ]; then
            # Create cluster
            echo "Creating cluster $AIRM_API_URL..."
            CLUSTER=$(curl -v -X 'POST' "${AIRM_API_URL}/v1/clusters" -H 'accept: application/json' -H "Authorization: Bearer ${TOKEN}" -H "Content-Type: application/json" -d '{ "base_url": "'"$CLUSTER_BASE_URL"'" }')
            
            CLUSTER_ID=$(echo "$CLUSTER" | jq -r '.id')
            check_success $([[ "$CLUSTER_ID" != "null" ]] && echo 0 || exit 1) "Failed to create cluster"
            CLUSTER_SECRET=$(echo "$CLUSTER" | jq -r '.user_secret')
        else
            echo "Cluster already exists with ID: $CLUSTER_EXISTS"
            CLUSTER_ID=$CLUSTER_EXISTS
            # Optionally, fetch the existing cluster's secret if needed.  This assumes the secret is retrievable.
            CLUSTER_SECRET=$(curl -v -s -X GET "${AIRM_API_URL}/v1/clusters/$CLUSTER_ID" -H "Authorization: Bearer ${TOKEN}" | jq -r '.user_secret')
        fi
    }

    function create_secret_and_start_dispatcher() {
        # Create secret for dispatcher to use
        kubectl delete secret airmchartdemo-airm-rabbitmq-common-vhost-user -n 'silodemo-airm' 
        kubectl create secret generic airmchartdemo-airm-rabbitmq-common-vhost-user --from-literal=username="$CLUSTER_ID" --from-literal=password="$CLUSTER_SECRET" -n 'silodemo-airm'

        sleep 10
        # Start dispatcher because it has been failing because secret was not created and wait for 10 seconds
        # kubectl rollout restart deployment/airm-dispatcher -n 'silodemo-airm'
        echo "Just waiting 20 seconds for dispatcher deployment to rollout and take the secret that has been created"
    }

    function create_project() {
        PROJECT_ID=$(curl -v -s -X GET "${AIRM_API_URL}/v1/projects" -H 'accept: application/json' -H "Authorization: Bearer ${TOKEN}" | jq -r '.projects[] | select(.name=="'$PROJECT_NAME'") | .id')

        for (( i=0; i<=$TIMEOUT; i+=$SLEEP_INTERVAL )); do
            CLUSTER_STATUS=$(curl -v -s -X GET "${AIRM_API_URL}/v1/clusters/$CLUSTER_ID" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H 'Content-Type: application/json' | jq -r '.status')

            if [ "$CLUSTER_STATUS" == "healthy" ]; then
            echo "Cluster is healthy!"
            break # Exit the loop if the cluster is healthy
            fi
            echo "Cluster status: $CLUSTER_STATUS.  Waiting $SLEEP_INTERVAL seconds... ($i/$TIMEOUT seconds elapsed)"
            sleep $SLEEP_INTERVAL
        done

        if [ "$CLUSTER_STATUS" != "healthy" ]; then
            echo "ERROR: Cluster did not become healthy within $TIMEOUT seconds."
            exit 1
        fi

        if [ -z "$PROJECT_ID" ] || [ "$PROJECT_ID" == "null" ]; then
            echo "Projects '$PROJECT_NAME' not found. Creating..."
            PROJECT_ID=$(curl -v -X 'POST' \
            "${AIRM_API_URL}/v1/projects" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${TOKEN}" \
            -H 'Content-Type: application/json' \
            -d '{
                "name": "'"$PROJECT_NAME"'",
                "description": "'"$PROJECT_DESCRIPTION"'",
                "cluster_id": "'"$CLUSTER_ID"'",
                "quota": {
                "cpu_milli_cores": 0,
                "memory_bytes": 0,
                "ephemeral_storage_bytes": 0,
                "gpu_count": 0
                }
            }' | jq -r '.id')
            echo $PROJECT_ID
            check_success $([[ "$PROJECT_ID" != "null" ]] && echo 0 || echo 1) "Failed to create project"
        else
            echo "Project '$PROJECT_NAME' already exists with ID: $PROJECT_ID"
        fi
    }

    function add_user_to_project() {
        # Get project id
        USER_IN_PROJECT=$(curl -v -X 'GET' \
        "${AIRM_API_URL}/v1/users" \
        -H 'accept: application/json' \
        -H "Authorization: Bearer ${TOKEN}" | jq -r  '.users[] | select(.projects.id=="'$PROJECT_ID'" and .email=="'$USER_EMAIL'") | .id ')

        USER_ID=$(curl -v -X 'GET' \
        "${AIRM_API_URL}/v1/users" \
        -H 'accept: application/json' \
        -H "Authorization: Bearer ${TOKEN}" | jq -r  '.users[] | select(.email=="'$USER_EMAIL'") | .id ')

        # Add user to project if they are not already in it
        if [ -z "$USER_IN_PROJECT" ] || [ "$USER_IN_PROJECT" == "null" ]; then
            echo "Adding user '$USER_ID' to project '$PROJECT_ID'..."
            ADD_PROJECT_RESP=$(curl -v -w "%{http_code}" -o /dev/null -X 'POST' \
            "${AIRM_API_URL}/v1/projects/${PROJECT_ID}/users" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H 'Content-Type: application/json' \
            -d '{"user_ids": ["'${USER_ID}'"]}')
            echo $ADD_PROJECT_RESP
            check_success $([[ "$ADD_PROJECT_RESP" == "200" || "$ADD_PROJECT_RESP" == "201" || "$ADD_PROJECT_RESP" == "204" ]] && echo 0 || echo 1) "Failed to add user to project"
        else
            echo "User '$USER_ID' already exists in project '$PROJECT_ID'."
        fi
    }

    function add_minio_secret_to_project() {

        for (( i=0; i<=TIMEOUT; i+=SLEEP_INTERVAL )); do
            PROJECT_STATUS=$(curl -s -X GET "${AIRM_API_URL}/v1/projects/$PROJECT_ID" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H 'Content-Type: application/json' | jq -r '.status')

            if [ "$PROJECT_STATUS" == "Ready" ]; then
            echo "Project is ready!"
            break # Exit the loop if the project is ready
            fi
            echo "Project status: $PROJECT_STATUS.  Waiting $SLEEP_INTERVAL seconds... ($i/$TIMEOUT seconds elapsed)"
            sleep $SLEEP_INTERVAL
        done


        SECRET_IN_PROJECT=$(curl -X 'GET' \
        "${AIRM_API_URL}/v1/projects/${PROJECT_ID}/secrets" \
        -H 'accept: application/json' \
        -H "Authorization: Bearer ${TOKEN}" | jq -r  '.project_secrets[] | select(.projects.id=="'"$PROJECT_ID"'") | .id ')
        SECRET_NAME="minio-credentials-fetcher"
        EXTERNAL_SECRET_API_VERSION="v1beta1"
        EXTERNAL_SECRET_MANIFEST=$(cat <<EOF
    apiVersion: external-secrets.io/${EXTERNAL_SECRET_API_VERSION}
    kind: ExternalSecret
    metadata:
      name: ${SECRET_NAME}
    spec:
      data:
        - remoteRef:
            key: default-user
            property: API_ACCESS_KEY
            conversionStrategy: Default
            decodingStrategy: None
            metadataPolicy: None
          secretKey: minio-access-key
        - remoteRef:
            key: default-user
            property: API_SECRET_KEY
            conversionStrategy: Default
            decodingStrategy: None
            metadataPolicy: None
          secretKey: minio-secret-key
      refreshInterval: 1h
      secretStoreRef:
        kind: ClusterSecretStore
        name: k8s-secret-store
      target:
        creationPolicy: Owner
        name: minio-credentials
    EOF
    )
        if [ -z "$SECRET_IN_PROJECT" ] || [ "$SECRET_IN_PROJECT" == "null" ]; then
            echo "Adding secret to project '$PROJECT_ID'..."
            ADD_SECRET_RESP=$(curl -w "%{http_code}" -o /dev/null -X 'POST' \
            "${AIRM_API_URL}/v1/secrets" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H 'Content-Type: application/json' \
            -d '{
                "name": "'"$SECRET_NAME"'",
                "project_ids": ["'"$PROJECT_ID"'"],
                "type": "External",
                "scope": "Organization",
                "manifest": '"$(echo "$EXTERNAL_SECRET_MANIFEST" | jq -Rs .)"'
            }')
            echo "$ADD_SECRET_RESP"
            check_success "$([[ "$ADD_SECRET_RESP" == "200" || "$ADD_SECRET_RESP" == "201" || "$ADD_SECRET_RESP" == "204" ]] && echo 0 || echo 1)" "Failed to add minio secret to project"
        else
            echo "Secret already exists in project '$PROJECT_ID'."
        fi
    }


    echo "Waiting 10 seconds..."
    sleep 10

    # CLUSTER_BASE_URL="https://workspaces-demo.app-dev.silogen.ai/"
    # export CLUSTER_BASE_URL

    echo ""
    echo "Creating demo organization"
    echo ""

    echo "Env vars..."
    echo $KEYCLOAK_CLIENT_ID
    echo $KEYCLOAK_CLIENT_SECRET
    echo $USER_EMAIL
    echo $KEYCLOAK_URL
    echo $AIRM_API_URL
    ORG_DOMAINS=$(echo "[\""$NEW_DOMAIN_NAME"\"]")
    export ORG_DOMAINS
    echo $ORG_DOMAINS
    echo $ORG_NAME
    echo ""

    PROJECT_NAME="demo"
    PROJECT_DESCRIPTION="demo"
    CLUSTER_NAME="demo-cluster"
    TIMEOUT=300
    SLEEP_INTERVAL=5

    echo "Fetching a keycloak token..."
    refresh_token
    echo "Done"
    echo ""

    echo "Create_org in airm-api..."
    create_org
    echo "Done"
    echo ""

    echo "Fetching a keycloak token again..."
    refresh_token
    echo "Done"
    echo ""
    echo "Add user to org..."
    add_user_to_org
    echo ""

    # Adding dispatcher...
    echo "refresh_token"
    refresh_token
    echo "create_cluster..."
    create_cluster

    # NOTE: Done by airm-configure-dispatcher-rbac.yaml has the deployment failing until this step runs to trigger correctly
    echo "create_secret_and_start_dispatcher..."
    create_secret_and_start_dispatcher
    echo ""

    echo "refresh_token"
    refresh_token
    echo "create_project..."
    create_project
    echo "refresh_token"
    refresh_token
    echo "add_user_to_project..."
    add_user_to_project

    echo ""
    add_minio_secret_to_project

    echo ""
    echo "Successfully created demo organization from keycloak in database"
    exit 0
---
# Source: airm-chart/templates/secret-generator-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: 'airmchartdemo-secret-generator-script'
  namespace: 'silodemo-airm'
data:
  generate-secrets.sh: |
    #!/bin/bash
    set -e
    
    # Generate alphanumeric secret function
    generate_secret() {
        openssl rand -hex 16 | tr 'a-f' 'A-F' | head -c 32
    }
    
    # Generate all secrets first
    AIRM_UI_SECRET=$(generate_secret)
    AIRM_ADMIN_SECRET=$(generate_secret)
    AIRM_CI_SECRET=$(generate_secret)
    CATALOG_SUPERUSER=$(generate_secret)
    CATALOG_USER=$(generate_secret)
    CATALOG_USERNAME=$(generate_secret)
    CHAT_AUTH_SECRET=$(generate_secret)
    DOCKER_PULL_SECRET=$(generate_secret)
    KC_FRONTEND_SECRET=$(generate_secret)
    KC_CREDENTIALS=$(generate_secret)
    SILOGEN_REALM=$(generate_secret)
    AIRM_REALM=$(generate_secret)
    KC_INTERNAL_ID=$(generate_secret)
    KC_INTERNAL_SECRET=$(generate_secret)
    KC_CI_SECRET=$(generate_secret)
    KC_INITIAL_PASSWORD=$(generate_secret)
    KC_SUPERUSER_USERNAME=$(generate_secret)
    AIRM_SUPERUSER_USERNAME=$(generate_secret)
    AIRM_RABBITMQ_USERNAME=$(generate_secret)
    AIRM_OCI_RABBITMQ_USERNAME=$(generate_secret)
    RABBITMQ_BACKUP_CREDS=$(generate_secret)
    KC_SUPERUSER_PASSWORD=$(generate_secret)
    AIRM_SUPERUSER_PASSWORD=$(generate_secret)
    AIRM_USER_PASSWORD=$(generate_secret)
    AIRM_RABBITMQ_PASSWORD=$(generate_secret)
    AIRM_OCI_RABBITMQ_PASSWORD=$(generate_secret)
    HMAC_ACCESS_KEY=$(generate_secret)
    HMAC_SECRET_KEY=$(generate_secret)
    DOCKER_PULL_SECRET2=$(generate_secret)
    AIRM_LEGACY_AUTH=$(generate_secret)
    RABBITMQ_DEFAULT_PASSWORD=$(generate_secret)
    
    # Create the ClusterSecretStore YAML with pre-generated secrets
    cat > /tmp/final-secret-store.yaml << EOF
    apiVersion: external-secrets.io/v1beta1
    kind: ClusterSecretStore
    metadata:
      name: airm-secret-store
    spec:
      provider:
        fake:
          data:
          - key: loki_tenant_name_oci1
            value: loki_tenant_oci1
          - key: loki_tenant_name_oci2
            value: loki_tenant_oci2
          - key: loki_tenant_name_ocisilogen
            value: loki_tenant_ocisilogen
          - key: loki_tenant_name_ociops
            value: loki_tenant_ociops
          - key: loki_tenant_password_ociclusters
            value: loki_tenant_password_ociclusters
          - key: .htpasswd
            value: "cluster-forge-mimir-test-user:\$apr1\$mszGHRfu\$fDCiA32oRdtP8tXGTTn2M0"
          - key: grafana-admin-id
            value: admin
          - key: grafana-admin-pw
            value: password
          - key: airm-ui-keycloak-secret
            value: ${AIRM_UI_SECRET}
          - key: airm-keycloak-admin-client-id
            value: admin-client-id-value
          - key: airm-keycloak-admin-client-secret
            value: ${AIRM_ADMIN_SECRET}
          - key: airm-ci-client-secret
            value: ${AIRM_CI_SECRET}
          - key: airmchartdemo-airm-cnpg-user
            value: airmchartdemo-airm-cnpg-user
          - key: catalog-cnpg-superuser
            value: ${CATALOG_SUPERUSER}
          - key: catalog-cnpg-user
            value: ${CATALOG_USER}
          - key: catalog-cnpg-user-username
            value: ${CATALOG_USERNAME}
          - key: chat-legacy-auth-nextauth-secret
            value: ${CHAT_AUTH_SECRET}
          - key: docker-pull-k8s-external-secret
            value: ${DOCKER_PULL_SECRET}
          - key: keycloak-client-frontend-keycloak-secret
            value: ${KC_FRONTEND_SECRET}
          - key: keycloak-credentials
            value: ${KC_CREDENTIALS}
          - key: silogen-realm-credentials
            value: ${SILOGEN_REALM}
          - key: airm-realm-credentials
            value: ${AIRM_REALM}
          - key: keycloak-client-internal-keycloak-id
            value: ${KC_INTERNAL_ID}
          - key: keycloak-client-internal-keycloak-secret
            value: ${KC_INTERNAL_SECRET}
          - key: keycloak-client-ci-keycloak-secret
            value: ${KC_CI_SECRET}
          - key: keycloak-initial-admin-password
            value: ${KC_INITIAL_PASSWORD}
          - key: keycloak-cnpg-user-username
            value: keycloak
          - key: keycloak-cnpg-superuser-username
            value: ${KC_SUPERUSER_USERNAME}
          - key: airm-cnpg-superuser-username
            value: ${AIRM_SUPERUSER_USERNAME}
          - key: airm-cnpg-user-username
            value: airm_user
          - key: airm-rabbitmq-user-username
            value: ${AIRM_RABBITMQ_USERNAME}
          - key: airm-oci-1-rabbitmq-common-vhost-username
            value: ${AIRM_OCI_RABBITMQ_USERNAME}
          - key: airmchartdemo-rabbitmq-backup-minio-credentials
            value: ${RABBITMQ_BACKUP_CREDS}
          - key: keycloak-cnpg-superuser-password
            value: ${KC_SUPERUSER_PASSWORD}
          - key: keycloak-cnpg-user-password
            value: keycloak
          - key: keycloak_initial_admin_password
            value: admin
          - key: airm-cnpg-superuser-password
            value: ${AIRM_SUPERUSER_PASSWORD}
          - key: airm-cnpg-user-password
            value: ${AIRM_USER_PASSWORD}
          - key: airm-rabbitmq-user-password
            value: ${AIRM_RABBITMQ_PASSWORD}
          - key: airm-oci-1-rabbitmq-common-vhost-password
            value: ${AIRM_OCI_RABBITMQ_PASSWORD}
          - key: hmac-keys-access-key
            value: ${HMAC_ACCESS_KEY}
          - key: hmac-keys-secret-key
            value: ${HMAC_SECRET_KEY}
          - key: docker-pull-k8s-external-secret
            value: ${DOCKER_PULL_SECRET2}
          - key: airm-legacy-auth-nextauth-secret
            value: ${AIRM_LEGACY_AUTH}
          - key: rabbitmq-default-user-username
            value: username
          - key: rabbitmq-default-user-password
            value: ${RABBITMQ_DEFAULT_PASSWORD}
    EOF
    

    # do not apply if the secret store already exists
    kubectl get clustersecretstores.external-secrets.io airm-secret-store > /dev/null 2>&1
    if [ $? -eq 0 ] ; then
      echo "ClusterSecretStore already exists, skipping creation."
      exit 0
    fi
 
    kubectl apply -f /tmp/final-secret-store.yaml
    
    echo "ClusterSecretStore created successfully!"
    echo "Generated secrets with alphanumeric values only"
    exit 0
---
# Source: airm-chart/templates/airm-app-frontend.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: 'airmchartdemo-airm-ui-cluster-access-role'
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "create", "delete"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: 'airmchartdemo-airm-dispatcher-cluster-access-role'
rules:
- apiGroups: [""]
  resources: ["services", "namespaces", "configmaps", "pods"]
  verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "statefulsets", "daemonsets"]
  verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
- apiGroups: ["batch"]
  resources: ["jobs", "cronjobs"]
  verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
- apiGroups: ["kaiwo.silogen.ai"]
  resources: ["kaiwojobs", "kaiwoservices", "kaiwoqueueconfigs"]
  verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
- apiGroups: ["gateway.networking.k8s.io"]
  resources: ["httproutes"]
  verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
- apiGroups: ["networking.k8s.io"]
  resources: ["ingresses"]
  verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
- apiGroups: ["external-secrets.io"]
  resources: ["externalsecrets"]
  verbs: ["get", "list", "watch", "create", "delete", "update", "patch"]
- apiGroups: ["apiextensions.k8s.io"]
  resources: ["customresourcedefinitions"]
  verbs: ["get", "list"]
---
# Source: airm-chart/templates/secret-generator-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: 'airmchartdemo-secret-generator-role'
rules:
- apiGroups: ["external-secrets.io"]
  resources: ["clustersecretstores"]
  verbs: ["create", "update", "patch", "get", "list"]
---
# Source: airm-chart/templates/airm-app-frontend.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: 'airmchartdemo-airm-ui-cluster-access-binding'
subjects:
- kind: ServiceAccount
  name: 'airmchartdemo-airm-ui-sa'
  namespace: 'silodemo-airm'
roleRef:
  kind: ClusterRole
  name: 'airmchartdemo-airm-ui-cluster-access-role'
  apiGroup: rbac.authorization.k8s.io
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: 'airmchartdemo-airm-dispatcher-cluster-access-binding'
subjects:
- kind: ServiceAccount
  name: 'airmchartdemo-airm-dispatcher-sa'
  namespace: 'silodemo-airm'
roleRef:
  kind: ClusterRole
  name: 'airmchartdemo-airm-dispatcher-cluster-access-role'
  apiGroup: rbac.authorization.k8s.io
---
# Source: airm-chart/templates/secret-generator-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: 'airmchartdemo-secret-generator-binding'
subjects:
- kind: ServiceAccount
  name: 'airmchartdemo-secret-generator-sa'
  namespace: 'silodemo-airm'
roleRef:
  kind: ClusterRole
  name: 'airmchartdemo-secret-generator-role'
  apiGroup: rbac.authorization.k8s.io
---
# Source: airm-chart/templates/airm-app-backend.yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    app: 'airmchartdemo-airm-api'
  name: 'airmchartdemo-airm-api'
  namespace: 'silodemo-airm'
spec:
  ports:
    - name: web
      port: 80
      targetPort: 8080
    - name: metrics
      port: 9009
      targetPort: 9009
  selector:
    app: 'airmchartdemo-airm-api'
  type: ClusterIP
---
# Source: airm-chart/templates/airm-app-frontend.yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    app: 'airmchartdemo-airm-ui'
  name: 'airmchartdemo-airm-ui'
  namespace: 'silodemo-airm'
spec:
  ports:
    - name: web
      port: 80
      targetPort: 8000
  selector:
    app: 'airmchartdemo-airm-ui'
  type: ClusterIP
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: v1
kind: Service
metadata:
  name: 'airmchartdemo-airm-dispatcher'
  namespace: 'silodemo-airm'
  labels:
    app: 'airmchartdemo-airm-dispatcher'
spec:
  ports:
  - name: web
    port: 80
    targetPort: 8080
  type: ClusterIP
  selector:
    app: 'airmchartdemo-airm-dispatcher'
---
# Source: airm-chart/templates/airm-app-backend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: 'airmchartdemo-airm-api'
  namespace: 'silodemo-airm'
spec:
  replicas: 1
  selector:
    matchLabels:
      app: 'airmchartdemo-airm-api'
  template:
    metadata:
      labels:
        app: 'airmchartdemo-airm-api'
        auth-required: "true"
    spec:
      containers:
        - env:
            - name: OPENID_CLIENT_ID
              value: '354a0fa1-35ac-4a6d-9c4d-d661129c2cd0'
            - name: OPENID_CONFIGURATION_URL
              value: 'http://kc.not-a-domain/realms/airm/.well-known/openid-configuration'
            - name: POST_REGISTRATION_REDIRECT_URL
              value: 'https://airmui.not-a-domain/'
            - name: DATABASE_HOST
              value: 'airmchartdemo-airm-cnpg-rw.silodemo-airm.svc.cluster.local'
            - name: DATABASE_PORT
              value: '5432'
            - name: DATABASE_USER
              valueFrom:
                secretKeyRef:
                  key: username
                  name: 'airmchartdemo-airm-cnpg-user'
            - name: DATABASE_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: password
                  name: 'airmchartdemo-airm-cnpg-user'
            - name: RABBITMQ_HOST
              value: 'airmchartdemo-rabbitmq.silodemo-airm.svc.cluster.local'
            - name: RABBITMQ_PORT
              value: '5672'
            - name: RABBITMQ_MANAGEMENT_URL
              value: http://airmchartdemo-rabbitmq.silodemo-airm.svc.cluster.local:15672/api
            - name: RABBITMQ_ADMIN_USER
              valueFrom:
                secretKeyRef:
                  key: username
                  name: 'airmchartdemo-airm-rabbitmq-admin'
            - name: RABBITMQ_ADMIN_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: password
                  name: 'airmchartdemo-airm-rabbitmq-admin'
            - name: KEYCLOAK_ADMIN_SERVER_URL
              value: 'http://keycloak.keycloak.svc.cluster.local:8080'
            - name: KEYCLOAK_REALM
              value: airm
            - name: KEYCLOAK_ADMIN_CLIENT_ID
              valueFrom:
                secretKeyRef:
                  key: client-id
                  name: 'airmchartdemo-airm-keycloak-admin-client'
            - name: KEYCLOAK_ADMIN_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  key: client-secret
                  name: 'airmchartdemo-airm-keycloak-admin-client'
            - name: MINIO_URL
              value: 'http://minio.minio-tenant-default.svc.cluster.local:80'
            - name: MINIO_BUCKET
              value: 'default-bucket' 
            - name: MINIO_ACCESS_KEY
              valueFrom:
                secretKeyRef:
                  key: minio-access-key
                  name: 'airmchartdemo-api-minio-credentials'
            - name: MINIO_SECRET_KEY
              valueFrom:
                secretKeyRef:
                  key: minio-secret-key
                  name: 'airmchartdemo-api-minio-credentials'
            - name: PROMETHEUS_URL
              value: 'http://lgtm-stack.otel-lgtm-stack.svc.cluster.local:9090'
          image: 'ghcr.io/silogen/airm-api:v2025.08-rc.21'
          imagePullPolicy: IfNotPresent
          livenessProbe:
            failureThreshold: 3
            httpGet:
              path: /v1/health
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
            successThreshold: 1
            timeoutSeconds: 2
          name: airm
          ports:
            - containerPort: 8080
            - containerPort: 9009
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /v1/health
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
            successThreshold: 1
            timeoutSeconds: 2
          resources:
            limits:
              memory: 1Gi
            requests:
              cpu: 500m
              memory: 1Gi
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            runAsUser: 1000
            seccompProfile:
              type: RuntimeDefault
      initContainers:
        - name: init-migration-scripts
          command:
            - sh
            - -c
            - cp /code/migrations/* /mnt/code/migrations/
          image: 'ghcr.io/silogen/airm-api:v2025.08-rc.21'
          imagePullPolicy: 'IfNotPresent'
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            runAsNonRoot: true
            runAsUser: 1000
            seccompProfile:
              type: RuntimeDefault
          volumeMounts:
            - mountPath: /mnt/code/migrations
              name: airm-migration-volume
        - name: liquibase-migrate
          command:
            - liquibase
            - --url=jdbc:postgresql://airmchartdemo-airm-cnpg-rw.silodemo-airm.svc.cluster.local:5432/airm 
            - --username=$(DATABASE_USER)
            - --password=$(DATABASE_PASSWORD)
            - --logLevel=INFO
            - --changeLogFile=changelog/changelog.xml
            - update
          env:
            - name: DATABASE_USER
              valueFrom:
                secretKeyRef:
                  key: username
                  name: 'airmchartdemo-airm-cnpg-user'
            - name: DATABASE_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: password
                  name: 'airmchartdemo-airm-cnpg-user'
          image: 'quay.io/lib/liquibase:latest'
          imagePullPolicy: 'IfNotPresent'
          volumeMounts:
            - mountPath: /liquibase/changelog
              name: airm-migration-volume
              readOnly: true
        - name: charts-registration
          image: 'ghcr.io/silogen/airm-api:v2025.08-rc.21'
          imagePullPolicy: 'IfNotPresent'
          command: ['uv', 'run', '-m', 'app.charts.registration']
          env:
          - name: DATABASE_HOST
            value: 'airmchartdemo-airm-cnpg-rw.silodemo-airm.svc.cluster.local'
          - name: DATABASE_PORT
            value: '5432'
          - name: DATABASE_USER
            valueFrom:
              secretKeyRef:
                name: 'airmchartdemo-airm-cnpg-user'
                key: username
          - name: DATABASE_PASSWORD
            valueFrom:
              secretKeyRef:
                name: 'airmchartdemo-airm-cnpg-user'
                key: password
          - name: RABBITMQ_HOST
            value: 'airmchartdemo-rabbitmq.silodemo-airm.svc.cluster.local'
          - name: RABBITMQ_PORT
            value: '5672'
          - name: RABBITMQ_MANAGEMENT_URL
            value: http://airmchartdemo-rabbitmq.silodemo-airm.svc.cluster.local:15672/api
          - name: RABBITMQ_ADMIN_USER
            valueFrom:
              secretKeyRef:
                key: username
                name: 'airmchartdemo-airm-rabbitmq-admin'
          - name: RABBITMQ_ADMIN_PASSWORD
            valueFrom:
              secretKeyRef:
                key: password
                name: 'airmchartdemo-airm-rabbitmq-admin'
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            runAsUser: 1000
            seccompProfile:
              type: RuntimeDefault
            capabilities:
              drop:
              - ALL
        - name: check-rabbitmq-is-ready
          command:
          - /bin/bash
          - -c
          - |

            apt-get update -y 1> /dev/null 2>&1
            apt-get install ncat -y 1> /dev/null 2>&1
            while ! nc -z "$ENDPOINT_URL_TO_CHECK" "$ENDPOINT_PORT_TO_CHECK"; do
              echo "Waiting for Airm rabbitmq at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}..."
              sleep 3
            done
            echo "Airm rabbitmq is accepting connections at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}."
            sleep 3
            exit 0

          image: ubuntu:22.04
          imagePullPolicy: IfNotPresent 
          env:
          - name: ENDPOINT_URL_TO_CHECK
            value: "airmchartdemo-rabbitmq.silodemo-airm.svc.cluster.local"
          - name: ENDPOINT_PORT_TO_CHECK
            value: "15672" #""
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: false
            runAsUser: 0
            capabilities:
              drop:
                - ALL
              add:
                - SETUID
                - SETGID
                - CHOWN
                - DAC_OVERRIDE
                - FOWNER
                - FSETID
            seccompProfile:
              type: RuntimeDefault
      volumes:
        - emptyDir: {}
          name: airm-migration-volume
---
# Source: airm-chart/templates/airm-app-frontend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: 'airmchartdemo-airm-ui'
  namespace: 'silodemo-airm'
spec:
  replicas: 1
  selector:
    matchLabels:
      app: 'airmchartdemo-airm-ui'
  template:
    metadata:
      labels:
        app: 'airmchartdemo-airm-ui'
    spec:
      serviceAccountName: 'airmchartdemo-airm-ui-sa'
      volumes:
        - name: config-script
          configMap:
            name: 'airmchartdemo-airm-configure'
            defaultMode: 0755

      initContainers:
        - name: init-orgdb
          command:
          - /bin/bash
          - -c
          - |
            /opt/scripts/init-db.sh
          image: ubuntu:22.04
          imagePullPolicy: IfNotPresent 
          volumeMounts:
            - name: config-script
              mountPath: /opt/scripts
          env:
          - name: DEBIAN_FRONTEND
            value: 'noninteractive'
          - name: ORG_NAME
            value: 'demo'
          - name: NEW_DOMAIN_NAME
            value: 'not-a-domain'
          - name: KEYCLOAK_CLIENT_ID
            value: '354a0fa1-35ac-4a6d-9c4d-d661129c2cd0'
          - name: KEYCLOAK_CLIENT_SECRET
            valueFrom:
              secretKeyRef:
                key: KEYCLOAK_SECRET
                name: 'airmchartdemo-secrets-airm'
          - name: USER_EMAIL
            value: 'devuser@not-a-domain'
          - name: KEYCLOAK_URL
            value: 'http://keycloak.keycloak.svc.cluster.local:8080'
          - name: AIRM_API_URL
            value: 'http://airmchartdemo-airm-api.silodemo-airm.svc.cluster.local'
          - name: CLUSTER_BASE_URL
            value: 'https://workspaces.not-a-domain/'
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: false
            runAsUser: 0
            capabilities:
              drop:
                - ALL
              add:
                - SETUID
                - SETGID
                - CHOWN
                - DAC_OVERRIDE
                - FOWNER
                - FSETID
            seccompProfile:
              type: RuntimeDefault

      containers:
        - name: airm-ui
          env:
          - name: NEXTAUTH_URL
            value: 'https://airmui.not-a-domain'
          - name: KEYCLOAK_ISSUER
            value: 'https://kc.not-a-domain/realms/airm'
          - name: KEYCLOAK_ID
            value: '354a0fa1-35ac-4a6d-9c4d-d661129c2cd0'
          - name: KEYCLOAK_ISSUER_INTERNAL_URL
            value: 'http://keycloak.keycloak.svc.cluster.local:8080/realms/airm/'
          - name: AIRM_API_SERVICE_URL
            value: 'http://airmchartdemo-airm-api.silodemo-airm.svc.cluster.local'
          envFrom:
            - secretRef:
                name: 'airmchartdemo-secrets-airm'
          image: 'ghcr.io/silogen/airm-ui:v2025.08-rc.21'
          imagePullPolicy: 'IfNotPresent'
          livenessProbe:
            failureThreshold: 3
            httpGet:
              path: /api/health
              port: 8000
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 2
          name: airm-ui
          ports:
            - containerPort: 8000
          resources:
            limits:
              memory: 4Gi
            requests:
              cpu: 500m
              memory: 4Gi
          readinessProbe:
            httpGet:
              path: /api/health
              port: 8000
            initialDelaySeconds: 5
            periodSeconds: 10
      restartPolicy: Always
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: 'airmchartdemo-airm-dispatcher'
  namespace: 'silodemo-airm'
spec:
  replicas: 1
  selector:
    matchLabels:
      app: 'airmchartdemo-airm-dispatcher'
  template:
    metadata:
      labels:
        app: 'airmchartdemo-airm-dispatcher'
    spec:
      serviceAccountName: 'airmchartdemo-airm-dispatcher-sa'
      initContainers:
        - name: check-airm-api-is-ready
          command:
          - /bin/bash
          - -c
          - |

            apt-get update -y 1> /dev/null 2>&1
            apt-get install ncat -y 1> /dev/null 2>&1
            while ! nc -z "$ENDPOINT_URL_TO_CHECK" "$ENDPOINT_PORT_TO_CHECK"; do
              echo "Waiting for Airm UI at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}..."
              sleep 3
            done
            echo "Airm UI is accepting connections at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}."
            sleep 12
            exit 0

          image: ubuntu:22.04
          imagePullPolicy: IfNotPresent 
          # volumeMounts:
          #   - name: config-script
          #     mountPath: /opt/scripts
          env:
          - name: ENDPOINT_URL_TO_CHECK
            value: "airmchartdemo-airm-api.silodemo-airm.svc.cluster.local"
          - name: ENDPOINT_PORT_TO_CHECK
            value: "80" #""
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: false
            runAsUser: 0
            capabilities:
              drop:
                - ALL
              add:
                - SETUID
                - SETGID
                - CHOWN
                - DAC_OVERRIDE
                - FOWNER
                - FSETID
            seccompProfile:
              type: RuntimeDefault
      containers:
      - name: airm-dispatcher
        image: 'ghcr.io/silogen/airm-dispatcher:v2025.08-rc.21'
        imagePullPolicy: 'IfNotPresent'
        ports:
        - containerPort: 8080
        env:
        - name: KUBE_CLUSTER_NAME
          value: demo-cluster
        - name: ORG_NAME
          value: demo
        - name: RABBITMQ_HOST
          value: "airmchartdemo-rabbitmq.silodemo-airm.svc.cluster.local"
        - name: RABBITMQ_PORT
          value: "5672" #""
        - name: RABBITMQ_AIRM_COMMON_VHOST
          value: "vh_airm_common"
        - name: RABBITMQ_AIRM_COMMON_QUEUE
          value: "airm_common"
        - name: RABBITMQ_USER
          valueFrom:
            secretKeyRef:
              name: 'airmchartdemo-airm-rabbitmq-common-vhost-user'
              key: username
        - name: RABBITMQ_PASSWORD
          valueFrom:
            secretKeyRef:
              name: 'airmchartdemo-airm-rabbitmq-common-vhost-user'
              key: password
        livenessProbe:
          httpGet:
            path: /v1/health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 2
          failureThreshold: 3
          successThreshold: 1
        readinessProbe:
          httpGet:
            path: /v1/health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 2
          failureThreshold: 3
          successThreshold: 1
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "1Gi"
        securityContext:
          runAsUser: 0
---
# Source: airm-chart/templates/secret-generator-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: 'airmchartdemo-secret-generator'
  namespace: 'silodemo-airm'
spec:
  template:
    spec:
      serviceAccountName: 'airmchartdemo-secret-generator-sa'
      containers:
      - name: secret-generator
        image: 'ghcr.io/silogen/kubectl:latest'
        imagePullPolicy: 'IfNotPresent'
        command: ["/bin/bash"]
        args: ["/scripts/generate-secrets.sh"]
        volumeMounts:
        - name: script-volume
          mountPath: /scripts
      volumes:
      - name: script-volume
        configMap:
          name: 'airmchartdemo-secret-generator-script'
          defaultMode: 0755
      restartPolicy: OnFailure
  backoffLimit: 3
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: 'airmchartdemo-cluster-nodes-dispatcher'
  namespace: 'silodemo-airm'
spec:
  concurrencyPolicy: Replace
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - command:
                - curl
                - -X
                - POST
                - http://airmchartdemo-airm-dispatcher:80/v1/clusters/nodes
              image: 'ghcr.io/silogen/airm-dispatcher:v2025.08-rc.21'
              imagePullPolicy: 'IfNotPresent'
              name: airm-cluster-nodes-cron
              resources:
                limits:
                  memory: 100Mi
                requests:
                  cpu: 50m
                  memory: 100Mi
          restartPolicy: OnFailure
  schedule: 0 * * * *
---
# Source: airm-chart/templates/airm-dispatcher-app.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: 'airmchartdemo-heartbeat-dispatcher'
  namespace: 'silodemo-airm'
spec:
  concurrencyPolicy: Replace
  schedule: "*/1 * * * *"
  suspend: false
  jobTemplate:
    spec:
      template:
        metadata:
          annotations:
            sidecar.istio.io/inject: "false"
        spec:
          restartPolicy: OnFailure

          initContainers:
            - name: check-dispatcher-is-ready
              command:
              - /bin/bash
              - -c
              - |

                apt-get update -y 1> /dev/null 2>&1
                apt-get install ncat -y 1> /dev/null 2>&1
                while ! nc -z "$ENDPOINT_URL_TO_CHECK" "$ENDPOINT_PORT_TO_CHECK"; do
                  echo "Waiting for Airm dispatcher at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}..."
                  sleep 3
                done
                echo "Airm dispatcher is accepting connections at ${ENDPOINT_URL_TO_CHECK}:${ENDPOINT_PORT_TO_CHECK}."
                sleep 12
                exit 0

              image: ubuntu:22.04
              imagePullPolicy: IfNotPresent 
              # volumeMounts:
              #   - name: config-script
              #     mountPath: /opt/scripts
              env:
              - name: ENDPOINT_URL_TO_CHECK
                value: "airmchartdemo-airm-dispatcher.silodemo-airm.svc.cluster.local"
              - name: ENDPOINT_PORT_TO_CHECK
                value: "80" #""
              securityContext:
                allowPrivilegeEscalation: false
                runAsNonRoot: false
                runAsUser: 0
                capabilities:
                  drop:
                    - ALL
                  add:
                    - SETUID
                    - SETGID
                    - CHOWN
                    - DAC_OVERRIDE
                    - FOWNER
                    - FSETID
                seccompProfile:
                  type: RuntimeDefault
          containers:
          - name: airm-heartbeat-cron
            image: 'ghcr.io/silogen/airm-dispatcher:v2025.08-rc.21'
            imagePullPolicy: 'IfNotPresent'
            command: ["curl", "-X", "POST", "http://airmchartdemo-airm-dispatcher:80/v1/heartbeats"]
            resources:
              requests:
                memory: "100Mi"
                cpu: "50m"
              limits:
                memory: "100Mi"
---
# Source: airm-chart/templates/airm-cert-issuer.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: 'airmchartdemo-tls-secret'
  namespace: 'silodemo-airm'
spec:
  dnsNames:
    - 'airmchartdemo-rabbitmq.silodemo-airm.svc.cluster.local'
    - '*.airmchartdemo-rabbitmq-nodes.silodemo-airm.svc.cluster.local'
  issuerRef:
    kind: Issuer
    name: 'airmchartdemo-selfsigned-issuer'
  secretName: 'airmchartdemo-tls-secret'
---
# Source: airm-chart/templates/airm-cluster.yaml
apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: 'airmchartdemo-airm-cnpg'
  namespace: 'silodemo-airm'
spec:
  affinity:
    enablePodAntiAffinity: true
    topologyKey: topology.kubernetes.io/zone
  bootstrap:
    initdb:
      database: airm
      owner: airm_user
      postInitSQL:
        - GRANT CREATE ON SCHEMA public TO airm_user
      secret:
        name: 'airmchartdemo-airm-cnpg-user'
  imageName: ghcr.io/cloudnative-pg/postgresql:17
  instances: 1
  nodeMaintenanceWindow:
    inProgress: false
    reusePVC: true
  postgresql:
    parameters:
      auto_explain.log_min_duration: "10s"
      pg_stat_statements.max: "10000"
      pg_stat_statements.track: "all"
      shared_buffers: "256MB"
      wal_compression: "pglz" # default is "off"
    pg_hba:
      - host all all 10.244.0.0/16 md5
  primaryUpdateStrategy: unsupervised
  resources:
    limits:
      cpu: "2"
      memory: 1Gi
    requests:
      cpu: "1"
      memory: 512Mi
  startDelay: 300
  stopDelay: 300
  storage:
    size: 50Gi
    storageClass: default
  superuserSecret:
    name: 'airmchartdemo-airm-cnpg-superuser' # airm-cnpg-superuser
  walStorage:
    size: 50Gi
    storageClass: default
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: 'airmchartdemo-airm-cnpg-superuser'
  namespace: 'silodemo-airm'
spec:
  data:
    - remoteRef:
        key: airm-cnpg-superuser-username
      secretKey: username
    - remoteRef:
        key: airm-cnpg-superuser-password
      secretKey: password
  secretStoreRef:
    kind: ClusterSecretStore
    name: airm-secret-store
  target:
    name: 'airmchartdemo-airm-cnpg-superuser'
    template:
      type: Opaque
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: 'airmchartdemo-airm-cnpg-user'
  namespace: 'silodemo-airm'
spec:
  data:
    - remoteRef:
        key: airm-cnpg-user-username
      secretKey: username
    - remoteRef:
        key: airm-cnpg-user-password
      secretKey: password
  secretStoreRef:
    kind: ClusterSecretStore
    name: airm-secret-store
  target:
    name: 'airmchartdemo-airm-cnpg-user'
    template:
      type: Opaque
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name:  'airmchartdemo-airm-keycloak-admin-client'
  namespace: 'silodemo-airm'
spec:
  data:
    - remoteRef:
        key: airm-keycloak-admin-client-id
      secretKey: client-id
    - remoteRef:
        key: airm-keycloak-admin-client-secret
      secretKey: client-secret
  secretStoreRef:
    kind: ClusterSecretStore
    name: airm-secret-store
  target:
    name: 'airmchartdemo-airm-keycloak-admin-client'
    template:
      type: Opaque
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: 'airmchartdemo-airm-rabbitmq-admin'
  namespace: 'silodemo-airm'
spec:
  data:
    - remoteRef:
        key: airm-rabbitmq-user-username
      secretKey: username
    - remoteRef:
        key: airm-rabbitmq-user-password
      secretKey: password
  secretStoreRef:
    kind: ClusterSecretStore
    name: airm-secret-store
  target:
    name: 'airmchartdemo-airm-rabbitmq-admin'
    template:
      data:
        default_user.conf: |
          default_user = {{ .username }}
          default_pass = {{ .password }}
        password: '{{ .password }}'
        username: '{{ .username }}'
      type: Opaque
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: 'airmchartdemo-api-minio-credentials'
  namespace: 'silodemo-airm'
spec:
  data:
    - remoteRef:
        key: default-user
        property: API_ACCESS_KEY
      secretKey: minio-access-key
    - remoteRef:
        key: default-user
        property: API_SECRET_KEY
      secretKey: minio-secret-key
  secretStoreRef:
    kind: ClusterSecretStore
    name: k8s-secret-store
  target:
    name: 'airmchartdemo-api-minio-credentials'
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: 'airmchartdemo-rabbitmq-backup-minio-credentials'
  namespace: 'silodemo-airm'
spec:
  data:
    - remoteRef:
        key: hmac-keys-access-key
      secretKey: access_key
    - remoteRef:
        key: hmac-keys-secret-key
      secretKey: secret_key
  secretStoreRef:
    kind: ClusterSecretStore
    name: airm-secret-store
  target:
    name: 'airmchartdemo-rabbitmq-backup-minio-credentials'
---
# Source: airm-chart/templates/airm-es.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: 'airmchartdemo-secrets-airm'
  namespace: 'silodemo-airm'
spec:
  data:
    - remoteRef:
        key: airm-legacy-auth-nextauth-secret
      secretKey: NEXTAUTH_SECRET
    - remoteRef:
        key: airm-ui-keycloak-secret
      secretKey: KEYCLOAK_SECRET
  refreshInterval: 15s
  secretStoreRef:
    kind: ClusterSecretStore
    name: airm-secret-store
  target:
    name: 'airmchartdemo-secrets-airm'
---
# Source: airm-chart/templates/airm-httproute.yaml
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: 'airmchartdemo-airmapi-route'
  namespace: 'silodemo-airm'
spec:
  parentRefs:
  - group: gateway.networking.k8s.io
    kind: Gateway
    name: https
    namespace: kgateway-system
  rules:
  - backendRefs:
    - group: ""
      kind: Service
      name: 'airmchartdemo-airm-api'
      port: 80
      weight: 1
    matches:
    - headers:
      - name: Host
        type: RegularExpression
        value: airmapi\..*
      path:
        type: PathPrefix
        value: /
    timeouts:
      backendRequest: 20s
      request: 90s
---
# Source: airm-chart/templates/airm-httproute.yaml
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: 'airmchartdemo-airmui-route'
  namespace: 'silodemo-airm'
spec:
  parentRefs:
  - group: gateway.networking.k8s.io
    kind: Gateway
    name: https
    namespace: kgateway-system
  rules:
  - backendRefs:
    - group: ""
      kind: Service
      name: 'airmchartdemo-airm-ui'
      port: 80
      weight: 1
    matches:
    - headers:
      - name: Host
        type: RegularExpression
        value: airmui\..*
      path:
        type: PathPrefix
        value: /
    timeouts:
      backendRequest: 20s
      request: 90s
---
# Source: airm-chart/templates/airm-cert-issuer.yaml
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: 'airmchartdemo-selfsigned-issuer'
  namespace: 'silodemo-airm'
spec:
  selfSigned: {}
---
# Source: airm-chart/templates/airm-rabbitmq-cluster.yaml
apiVersion: rabbitmq.com/v1beta1
kind: RabbitmqCluster
metadata:
  name: 'airmchartdemo-rabbitmq'
  namespace: 'silodemo-airm'
spec:
  persistence:
    storage: 20Gi
    storageClassName: default
  replicas: 1
  resources:
    limits:
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi
  secretBackend:
    externalSecret:
      name: 'airmchartdemo-airm-rabbitmq-admin'
  tls:
    secretName: 'airmchartdemo-tls-secret'
