apiVersion: v1
kind: ConfigMap
metadata:
  name: openbao-init-scripts
  namespace: cf-openbao
data:
  init-openbao.sh: |
    #!/bin/bash
    
    set -e
    
    {{- if eq (.Values.server.ha.enabled | toString) "true" }}
    REPLICAS={{ .Values.server.ha.replicas | default 3 }}
    {{- else }}
    REPLICAS=1
    {{- end }}
    
    echo "Checking OpenBao status on openbao-0..."
    if kubectl exec openbao-0 -n cf-openbao -- bao status 2>&1 | grep -q "Initialized.*true"; then
      echo "OpenBao is already initialized. Skipping initialization."
      exit 0
    fi
    
    echo "Initializing OpenBao on openbao-0..."
    INIT_OUTPUT=$(kubectl exec openbao-0 -- bao operator init -format=json -key-shares=1 -key-threshold=1)
    echo $INIT_OUTPUT > /tmp/bao-keys.json;

    echo "Saving unseal keys and root token to openbao-keys k8s secret..."        
    BAO_ROOT_TOKEN=$(jq -r '.root_token' /tmp/bao-keys.json);
    BAO_UNSEAL_KEY=$(jq -r '.unseal_keys_b64[0]' /tmp/bao-keys.json);    
    kubectl create secret generic openbao-keys -n cf-openbao \
      --from-literal=root_token="$BAO_ROOT_TOKEN" \
      --from-literal=unseal_key="$BAO_UNSEAL_KEY" \
      --dry-run=client -o yaml | kubectl apply -f -
    
    echo "Unsealing openbao-0..."
    kubectl exec openbao-0 -n cf-openbao -- bao operator unseal "$BAO_UNSEAL_KEY"
    kubectl wait --for=condition=ready pod/openbao-0 --timeout=300s -n cf-openbao
    
    if [ "$REPLICAS" -gt 1 ]; then
      echo "Setting up Raft cluster with $REPLICAS replicas..."
      for i in $(seq 1 $((REPLICAS - 1))); do
        echo "Unsealing openbao-$i & joining to Raft cluster..."
        kubectl exec openbao-$i -n cf-openbao -- bao operator raft join http://openbao-0.openbao-internal:8200
        kubectl exec openbao-$i -n cf-openbao -- bao operator unseal "$BAO_UNSEAL_KEY"
        kubectl wait --for=condition=ready pod/openbao-$i --timeout=300s -n cf-openbao
      done
      echo "OpenBao Raft cluster initialization completed successfully!"
    else
      echo "OpenBao standalone initialization completed successfully!"
    fi
    
  setup-openbao.sh: |
    #!/bin/bash
    
    set -e
    
    generate_password() {
        openssl rand -hex 16 | tr 'a-f' 'A-F' | head -c 32
    }
    
    export BAO_TOKEN=$(kubectl get secret openbao-keys -n cf-openbao -o jsonpath='{.data.root_token}' | base64 -d)
     if [ -z "$BAO_TOKEN" ]; then
      echo "ERROR: Failed to retrieve root token from openbao-keys k8s secret"
      exit 1
    fi
        
    READONLY_PASSWORD=$(generate_password)
    
    kubectl create secret generic openbao-user \
      --from-literal=username=readonly-user \
      --from-literal=password=$READONLY_PASSWORD \
      --dry-run=client -o yaml | kubectl apply -f -
    
    echo "Enabling secrets KV engine..."
    if bao secrets list 2>/dev/null | grep -q "^secrets/"; then
      echo "Secrets engine already exists"
    else
     bao secrets enable -version=2 -path=secrets kv
    fi    

    echo "Enabling apikey-groups KV engine..."
    if bao secrets list 2>/dev/null | grep -q "^apikey-groups/"; then
      echo "apikey-groups engine already exists"
    else
     bao secrets enable -version=2 -path=apikey-groups kv
    fi

    echo "Configuring userpass auth..."
    if bao auth list 2>/dev/null | grep -q "^userpass/"; then
      echo "userpass auth already exists"
    else
      bao auth enable userpass
    fi
    
    echo "Creating read-policy..."
    echo '
    path "secrets/data/*" {
      capabilities = ["read"]
    }
    path "secrets/metadata/*" {
      capabilities = ["list"]
    }
    path "auth/token/lookup-self" {
      capabilities = ["read"]
    }
    path "auth/token/renew-self" {
      capabilities = ["update"]
    }' | bao policy write read-policy -
    
    echo "Creating reader-role..."
    bao write auth/userpass/users/readonly-user \
      policies=read-policy \
      password=$READONLY_PASSWORD
    
    echo "OpenBao configuration completed successfully!"

  generate-secrets.sh: |
    #!/bin/bash

    DOMAIN={{ .Values.domain }}

    set -e

    export BAO_TOKEN=$(kubectl get secret openbao-keys -n cf-openbao -o jsonpath='{.data.root_token}' | base64 -d)
     if [ -z "$BAO_TOKEN" ]; then
      echo "ERROR: Failed to retrieve root token from openbao-keys k8s secret"
      exit 1
    fi
    
    echo "Generating secrets..."
    
    bao kv put secrets/cluster-domain value=${DOMAIN};
    
    bao kv put secrets/airm-cnpg-user-username value=airm_user;
    bao kv put secrets/airm-cnpg-user-password value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/airm-cnpg-superuser-username value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/airm-cnpg-superuser-password value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    
    bao kv put secrets/airm-rabbitmq-user-username value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/airm-rabbitmq-user-password value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    
    bao kv put secrets/airm-ui-keycloak-secret value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/airm-ui-auth-nextauth-secret value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/airm-ci-client-secret value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    
    bao kv put secrets/airm-keycloak-admin-client-id value="admin-client-id-value"
    bao kv put secrets/airm-keycloak-admin-client-secret value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
        
    bao kv put secrets/keycloak-initial-admin-password value=admin;
    bao kv put secrets/keycloak-cnpg-user-username value=keycloak;
    bao kv put secrets/keycloak-cnpg-user-password value=keycloak;
    bao kv put secrets/keycloak-cnpg-superuser-username value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/keycloak-cnpg-superuser-password value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    
    bao kv put secrets/minio-api-access-key value=api-default-user;
    bao kv put secrets/minio-api-secret-key value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/minio-console-access-key value=default-user;
    bao kv put secrets/minio-console-secret-key value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/minio-root-password value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/minio-client-secret value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/minio-openid-url value="https://kc.${DOMAIN}/realms/airm/.well-known/openid-configuration"

    bao kv put secrets/k8s-client-secret value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/gitea-client-secret value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/argocd-client-secret value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";

    bao kv put secrets/cluster-auth-admin-token value="$(bao write -field=random_bytes sys/tools/random bytes=16 format=hex)";
    bao kv put secrets/cluster-auth-openbao-token value=${BAO_TOKEN};

    echo "Secrets have been generated successfully!"
